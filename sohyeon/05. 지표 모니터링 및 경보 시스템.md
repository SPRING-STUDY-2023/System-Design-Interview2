# 5장 지표 모니터링 및 경보 시스템

## 1️⃣ 문제 이해 및 설계 범위 확정

### 개략적 요구사항 및 가정
- 대규모 인프라를 모니터링 해야 함
  - 일간 능동 사용자 수 1억 명
  - 서버 풀 1,000개, 풀당 서버 수 100개. 서버당 100개의 운영 지표를 수집한다고 치면 모니터링해야 하는 지표의 수는 천만 개 수준
  - 데이터 보관 기간은 1년
  - 수집한 그대로 데이터를 보관하는 기간은 일주일. 그 뒤에는 1분 단위 데이터로 변환한 후에 30일간 보관. 그 뒤에는 1시간 단위 데이터로 변환한 뒤에 1년간 보관.
 
- 모니터링할 지표는 다양한데, 예를 들면 다음과 같은 것이 있음
  - CPU 사용률
  - 요청 수
  - 메모리 사용량
  - 메시지 큐 내의 메시지 수
 
<br/>

### 비기능 요구사항
- 규모 확장성: 시스템은 늘어나는 지표 수와 경보의 양에 맞게 확장될 수 있어야 한다.
- 낮은 응답 지연: 대시보드와 경보를 신속하게 처리할 수 있도록, 질의에 대한 낮은 응답 지연을 보장해야 한다.
- 안정성: 높은 안전성을 제공하여 중요 경보를 놓치지 않도록 해야 한다.
- 유연성: 기술은 계속 변화하므로, 미래의 신기술을 쉽게 통합할 수 있도록 유연하게 변경 가능한 파이프라인을 이용해 구축한 시스템이어야 한다.

<br/>

## 2️⃣ 개략적 설계안 제시 및 동의 구하기

### 기본적 사항
- 데이터 수집: 여러 출처로부터 지표 데이터를 수집한다.
- 데이터 전송: 지표 데이터를 지표 모니터링 시스템으로 전송한다.
- 데이터 저장소: 전송되어 오는 데이터를 정리하고 저장한다.
- 경보: 밀려오는 데이터를 분석하고, 이상 징후를 감지하고, 경보를 발생시킨다.
- 시각화: 데이터를 차트나 그래프 등으로 제공한다.

<br/>

### 데이터 모델
- 지표 데이터는 통상 시계열 데이터 형태로 기록한다. (타임스탬프)
- 시계열 각각에는 고유한 이름이 붙고, 선택적으로 레이블(label)을 붙이기도 한다.

<br/>

> **사례1**

- production에서 사용 중인 서버 인스턴스의 특정 시간대의 CPU 부하를 알고 싶다고 가정한다.
- 시계열 데이터로 지표 이름(metric name), 레이블(host:i631,env:prod), 그리고 특정한 시각에 측정된 지표 데이터로 구성할 수 있다.

<br/>

> **사례2**

- 지난 10분간 특정 지역(us-west)에 위치한 모든 웹 서버의 CPU 부하 평균값을 알고 싶다고 가정한다.
- 개념적으로 지표 이름이 CPU.load이고 레이블에 포함된 지역 이름이 us-west인 데이터를 저장소에서 가져와 평균값을 구하면 된다.

<br/>

> **데이터 접근 패턴**

- 예제 시스템은 쓰기 부하는 막대하고, 읽기 부하는 spiky(일시적으로 치솟았다 사라짐)한 편이다.

<br/>

### 데이터 저장소 시스템
- 시장에서 가장 인기 있는 시계열 데이터베이스 2가지는 다음과 같다. (from DB-engines)
  - InfluxDB
  - 프로메테우스(Prometheus)
 
- 다량의 시계열 데이터를 저장하고 빠른 실시간 분석을 지원한다.
- 메모리 캐시와 디스크 저장소를 함께 사용한다.

<br/>

### 개략적 설계안

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/6c4b05e0-6a27-4ab8-ac93-15d4e6c6af63"/>

🔼 개략적 설계안
- 지표 출처: 지표 데이터가 만들어지는 곳으로 애플리케이션 서버, SQL 데이터베이스, 메시지 큐 등 어떤 것이든 가능하다.
- 지표 수집기: 지표 데이터를 수집하고 시계열 데이터에 기록하는 역할을 한다.
- 시계열 데이터베이스: 지표 데이터를 시계열 데이터 형태로 보관하는 저장소다.
- 질의 서비스: 질의 서비스는 시계열 데이터베이스에 보관된 데이터를 질의하고 가져오는 과정을 돕는 서비스다.
- 경보 시스템: 경보를 받아야 하는 다양한 대상으로 경보 알림을 전송하는 역할을 하는 시스템이다.
- 시각화 시스템: 지표를 다양한 형태의 그래프/차트로 시각화 하는 기능을 제공하는 시스템이다.

<br/>

## 3️⃣ 상세 설계

### 지표 수집

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/ea3811ee-9586-4b66-8f49-4af93c63d264"/>

🔼 지표 수집 흐름

<br/>

#### 풀 vs 푸시 모델
- **풀 모델**
  - 지표 수집기가 실행 중인 애플리케이션에서 주기적으로 지표 데이터를 가져온다. (pull)
  - 각 서비스는 자신의 가용성 관련 정보를 서비스 탐색 서비스(SDS)에 기록하고, SDS는 서비스 엔드포인트 목록에 변화가 생길 때마다 지표 수집기에 통보한다.
  - 서비스 탐색 기술 기반 풀 모델

    <img alt="image" width="300" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/e10fbecc-9018-41a1-9ee9-318097842a2e"/>

    1. 지표 수집기는 SDS에서 서비스 엔드포인트 설정 메타데이터 목록을 가져온다.
    2. 지표 수집기는 사전에 합의된 HTTP 엔드포인트에서 지표 데이터를 가져온다.
    3. 지표 수집기는 서비스 엔드포인트 목록의 변화를 통지 받기 위한 변경 이벤트 알림 콜백을 서비스 탐색 컴포넌트에 등록할 수 있다.
   
  - 해시 링 구간마다 해당 구간에 속한 서버로부터 생산되는 지표의 수집을 담당하는 수집기 서버를 지정한다.
    - 특정 서버의 지표 데이터는 항상 하나의 수집 서버가 처리함을 보장
   
- **푸시 모델**
  - 웹 서버/데이터베이스 서버 같은 서버가 직접 지표를 수집기에 전송한다. (push)
  - 수집 에이전트는 해당 장비에서 실행되는 서비스가 생산하는 지표 데이터를 받아 모은 다음 주기적으로 수집기에 전달한다.
  - 지표 수집기 클러스터 자체도 자동 규모 확장이 가능하도록 구성하고 그 앞에 로드밸런서를 두는 것이 바람직하다.
 
- **풀 모델 vs 푸시 모델**
  - 사례
    - `pull`: Prometheus
    - `push`: CloudWatch, Graphite
   
  - 손쉬운 디버깅
    - `풀 모델`이 더 낫다.
   
  - 상태 진단 (health check)
    - `풀 모델` 쪽이 쉽다.
   
  - 생존 기간이 짧은 프로세스
    - 생명주기가 짧은 프로세스일 경우 지표를 다 끌어가기 전에 중단될 수 있다는 점을 고려하여 `푸시 모델`이 더 낫다.
   
  - 방화벽 등의 복잡한 네트워크 구성
    - `푸시 모델`이 낫다.
   
  - 성능
    - `풀 모델`은 일반적으로 TCP를 사용한다. (오버헤드 낮음)
    - `푸시 모델`은 보통 UDP를 사용한다. (지연 전송 낮음)
   
  - 데이터 신빙성
    - `풀 모델`은 가져올 지표 데이터가 이미 정의되어 있다.
    - `푸시 모델`은 아무나 지표 수집기에 데이터를 보낼 수 있으므로 인증(authentication)이 강제된다.
   
<br/>

### 지표 전송 파이프라인의 규모 확장

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/c9294ed1-5483-470c-995d-6c3aa7497f57"/>

🔼 지표 전송 파이프라인
- 스트림 처리 서비스가 카프카와 시계열 DB 중간에 위치하면 몇가지 장점이 있다. (카프카로부터 데이터를 받아 시계열 DB에 저장)
  - 카프카는 고도로 안정적이고 규모 확장성이 뛰어난 분산 메시지 플랫폼이다.
  - 데이터 수집 컴포넌트와 처리 컴포넌트 사이의 결합도를 낮춘다.
  - 데이터베이스에 장애가 생겨도 데이터는 소실되지 않는다. (카프카 보관)
 
<br/>

#### 카프카를 통한 규모 확장
- 대역폭 요구사항에 따라 파티션의 수를 설정한다.
- 지표 이름에 따라 어떤 지표를 어느 파티션에 배치할지 결정하면 소비자는 지표 이름에 따라 데이터를 집계할 수 있다.
- 태그/레이블에 따라 지표 데이터를 더욱 세분화한 파티션으로 나눈다.
- 중요 지표가 먼저 처리될 수 있도록 지표를 분류하고 우선순위를 지정한다.

<br/>

#### 카프카의 대안
- 고릴라(Gorilla): 페이스북의 메모리 기반 시계열 데이터베이스 시스템
- 일부 네트워크 장애가 발생해도 높은 수준의 쓰기 연산 가용성을 유지한다.

<br/>

### 데이터 집계 지점
- 수집 에이전트가 집계하는 방안
  - 클라이언트 측 집계 방안이다.
  - 복잡한 집계 로직은 지원하기 어렵다.
 
- 데이터 수집 파이프라인에서 집계하는 방안
  - 데이터를 저장소에 기록하기 전에 기록한다.
  - 원본 데이터 보관 X
 
- 질의 시 집계하는 방안
  - 데이터를 날것 그대로 보관한 다음 질의할 때 필요한 시간 구간에 맞게 집계한다.
  - 속도가 느리다.
 
<br/>

### 질의 서비스
- 질의 서버 클러스터 형태로 구현된다.
- 시각화/경보 시스템에서 접수된 요청을 시계열 데이터베이스를 통해 처리하는 역할을 담당한다.
- 질의 처리 전담 서비스를 두면 클라이언트와 시계열 데이터베이스 사이의 결합도를 낮출 수 있다.

<br/>

#### 캐시 계층
- 질의 결과를 저장할 캐시 서버를 도입하면 시계열 데이터베이스에 대한 질의 부하를 낮추고 질의 서비스의 성능을 높일 수 있다.

<br/>

#### 질의 서비스를 두면 곤란한 경우
- 관련 플러그인을 이미 갖추고 있을 경우
- 별도 캐시를 도입할 필요가 없을 경우

<br/>

#### 시계열 데이터베이스 질의어
- SQL가 아닌 독자 질의어를 제공한다. (SQL로 시계열 DB를 처리하기 까다로움)
- 시계열 데이터베이스 분석에 최적화된 플럭스(Flux)라는 언어로 작성하면 간단한 질의문이 만들어진다.

<br/>

### 저장소 계층

#### 시계열 데이터베이스는 신중하게 선택할 것
- 운영 데이터 저장소에 대한 질의의 85%는 지난 26시간 내에 수집된 데이터를 대상으로 한다.
- 시계열 데이터베이스를 적절하게 고르면 성능 측면에서 큰 이득을 볼 수 있다.

<br/>

#### 저장 용량 최적화
- 데이터 인코딩 및 압축
- 다운샘플링
  - 데이터의 해상도를 낮춰 저장소 요구량을 줄인다.
 
- 냉동 저장소
  - 잘 사용되지 않는 비활성 상태 데이터를 보관하는 곳이다.
 
<br/>

### 경보 시스템
1. 설정 파일을 가져와 캐시 서버에 보관한다.
2. 경보 관리자는 경보 설정 내역을 캐시에서 가져온다.
3. 설정된 규칙에 근거하여 경보 관리자는 지정된 시간마다 질의 서비스를 호출한다.
4. 경보 저장소는 카산드라 같은 형태의 키-값 저장소다. (적어도 한 번 알림 전달 보장)
5. 경보 이벤트를 카프카에 전달한다.
6. 경보 소비자는 카프카에서 경보 이벤트를 읽는다.
7. 경보 소비자는 카프카에서 읽은 경보 이벤트를 처리하여 이메일, 단문 메시지, 페이저듀티, HTTP 서비스 엔드포인트 등의 다양한 채널로 알림을 전송한다.

<br/>

#### 경보 시스템 - 만들 것인가 구매할 것인가
- 실무에서는 경보 시스템을 밑바닥부터 구현하겠다는 아이디어는 수용하기 어렵다.

<br/>

### 시각화 시스템
- 시각화 시스템은 데이터 계층 위에 만들어진다.
- 지표 대시보드에는 지표를 다양한 시간 범위로 표시하고, 경보 대시보드에는 다양한 경보의 상태를 표시한다.
- 상용품을 구입해서 쓰는 것이 바람직하다. (ex. Grafana)

<br/>

## 4️⃣ 마무리
- 지표 데이터 수집 모델: 풀 모델 vs 푸시 모델
- 카프카를 활용한 규모 확장 방안
- 최적 시계열 데이터베이스의 선정
- 다운샘플링을 통한 데이터 크기 절감
- 경보/시각화 시스템: 구현할 것인가 구입할 것인가

<br/>

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/3b6c9bbb-d9cf-4cdd-ab3c-c3e9a4ba352f"/>

🔼 최종 설계안
