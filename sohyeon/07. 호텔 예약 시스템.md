# 7장 호텔 예약 시스템

## 1️⃣ 문제 이해 및 설계 범위 확정

### 기능 요구사항
- 호텔 정보 페이지 표시
- 객실 정보 페이지 표시
- 객실 예약 지원
- 호텔이나 객실 정보를 추가/삭제/갱신하는 관리자 페이지 지원
- 초과 예약 지원

<br/>

### 비기능 요구사항
- 높은 수준의 동시성 지원
- 적절한 지연 시간 (최대 몇 초는 허용)

<br/>

### 개략적 규모 추정
- 총 5,000개 호텔, 100만 개의 객실이 있다고 가정한다.
- 평균적으로 객실의 70%가 사용 중이고, 평균 투숙 기간은 3일로 가정한다.
- 일일 예상 예약 견수 = 약 240,000 (1백만 * 0.7 / 3)
- 초당 예약 건수 = 약 3 (240,000 / 하루에 10^5초)
- 시스템 내 모든 페이지의 QPS (최종 단계 도달 전 90% 사용자는 이탈하는 것으로 가정)
  - 호텔/객실 상세 페이지: 약 300
  - 예약 상세 정보 페이지: 약 30
  - 객실 예약 페이지: 약 3
 
<br/>

## 2️⃣ 개략적 설계안 제시 및 동의 구하기

### API 설계

#### 호텔 관련 API

|API|설명|
|--|--|
|GET /v1/hotels/id|호텔의 상세 정보 반환|
|POST /v1/hotels|신규 호텔 추가 (호텔 직원용)|
|PUT /v1/hotels/id|호텔 정보 갱신 (호텔 직원용)|
|DELETE /v1/hotels/id|호텔 정보 삭제 (호텔 직원용)|

<br/>

#### 객실 관련 API

|API|설명|
|--|--|
|GET /v1/hotels/:id/rooms/id|객실 상세 정보 반환|
|POST /v1/hotels/:id/rooms|신규 객실 추가 (호텔 직원용)|
|PUT /v1/hotels/:id/rooms/id|객실 정보 갱신 (호텔 직원용)|
|DELETE /v1/hotels/:id/rooms/id|객실 정보 삭제 (호텔 직원용)|

<br/>

#### 예약 관련 API

|API|설명|
|---|---|
|GET /v1/reservations|로그인 사용자의 예약 이력 반환|
|GET /v1/reservations/id|특정 예약의 상세 정보 반환|
|POST /v1/reservations|신규 예약|
|DELETE /v1/reservations/id|예약 취소|

<br/>

### 데이터 모델
- `관계형 데이터베이스`를 선택한다.
  - 읽기 빈도가 쓰기 연산에 비해 높은 작업 흐름을 잘 지원한다.
  - ACID 속성을 보장한다.
  - 데이터를 쉽게 모델링할 수 있다. (구조/관계를 안정적으로 지원)
 
- 상태 천이도 다이어그램 (for 예약 상태)

  <img alt="image" width="500" src="https://github.com/user-attachments/assets/1bd3a43d-74bb-423a-8028-3fe74f7ab118" />

<br/>

### 개략적 설계안

<img alt="image" width="500" src="https://github.com/user-attachments/assets/539c6cd3-123b-4d65-9a3e-ff7141310ea4"/>

- 사용자: 객실을 예약하는 당사자
- 관리자(호텔직원): 관리 작업을 수행할 권리가 있는 호텔 직원
- CDN: 정적 컨텐츠를 캐시하여 로드 성능 개선
- 공개 API 게이트웨이: 완전 관리형 서비스
- 내부 API: 승인된 호텔 직원만 사용 가능한 API
- 호텔 서비스: 호텔/객실에 대한 상세 정보 제공
- 요금 서비스: 미래에 받아야 할 요금 데이터를 제공
- 예약 서비스: 예약 요청을 받고 객실을 예약하는 과정을 처리
- 결제 서비스: 고객의 결제 처리 (성공하면 결제 완료로, 실패하면 승인 실패로 상태값 업데이트)
- 호텔 관리 서비스: 승인된 호텔 직원만 사용 가능한 서비스

<br/>

## 3️⃣ 상세 설계

### 개선된 데이터 모델
- 호텔을 예약할 때 특정 객실이 아닌, 객실 유형을 예약하게 된다.
- roomID는 roomTypeID로 변경한다.
  - room: 객실에 관계된 정보를 담는다.
  - room_type_rate: 특정 객실 유형의 특정 일자 요금 정보를 담는다.
  - reservation: 투숙객 예약 정보를 담는다.
  - room_type_inventory: 호텔의 모든 객실 유형을 담는다.
    - hotel_id: 호텔 식별자
    - room_type_id: 객실 유형 식별자
    - date: 일자
    - total_inventory: 총 객실 수에서 일시적으로 제외한 객실 수를 뺀 값
    - total_reserved: 지정된 hotel_id, room_type_id에 예약된 모든 객실의 수
   
- Q. 예약 데이터가 단일 데이터베이스에 담기에 너무 크면 어떻게 할 것인가?
  - 현재/향후 예약 데이터만 저장한다. (예약 이력은 자주 접근하지 않으므로 아카이빙 하거나 냉동 저장소로 옮김)
  - 데이터베이스를 샤딩한다. (샤딩 키는 hotel_id)
 
<br/>

### 동시성 문제
1. 같은 사용자가 예약 버튼을 여러 번 누를 수 있다.
   - 클라이언트 측 구현: 클라이언트 요청 전송 후 `예약` 버튼을 비활성화시킨다.
   - 멱등 API: 예약 API 요청에 멱등 키를 추가한다. (ex. reservation_id)
  
2. 여러 사용자가 같은 객실을 동시에 예약하려 할 수 있다.
   - 비관적 락: 사용자가 레코드를 갱신하려고 하는 순간 즉시 락을 걸어 동시 업데이트를 방지한다.
     - 👍 변경 중이거나 변경이 끝난 데이터를 갱신하는 일을 막을 수 있다.
     - 👍 구현이 쉽고 모든 갱신 연산을 직렬화하여 충돌을 막는다.
     - 👎 여러 레코드에 락을 걸면 교착 상태(데드락)가 발생할 수 있다.
     - 👎 확장성이 낮다. (성능적 문제)
    
   - 낙관적 락: 여러 사용자가 동시에 같은 자원을 갱신하려 시도하는 것을 허용한다. (버전 번호 사용)
     - 👍 애플리케이션이 유효하지 않은 데이터를 편집하는 일을 막는다.
     - 👍 데이터베이스 자원에 락을 걸 필요가 없다. (버전 번호를 통해 데이터 일관성 유지)
     - 👍 데이터에 대한 경쟁이 치열하지 않은 상황에 적합하다.
     - 👎 데이터에 대한 경쟁이 치열한 상황에서는 성능이 좋지 않다.
     - 예약 QPS가 일반적으로 높지 않기 때문에 호텔 예약 시스템에서 적합하다.
    
   - 데이터베이스 제약 조건 (total_inventroy - total_reserved >= 0)
     - 👍 구현이 쉽다.
     - 👍 데이터에 대한 경쟁이 심하지 않을 때 잘 동작한다.
     - 👎 데이터에 대한 경쟁이 심하면 실패하는 연산 수가 급격히 늘어난다.
     - 👎 데이터베이스 제약 조건은 애플리케이션 코드와 달라서 버전을 통제하기 어렵다.
     - 👎 제약 조건을 허용하지 않는 데이터베이스도 있다.
     - 데이터에 대한 경쟁이 심하지 않은 호텔 예약 시스템에서 적합하다.
    
<br/>

### 시스템 규모 확장

#### 데이터베이스 샤딩
- 데이터베이스를 여러 대 두고, 각각에 데이터의 일부만 보관하도록 한다.
- hotel_id를 샤딩 조건으로 쓰면 좋다. (대부분 질의는 hotel_id를 필터링 조건으로 사용함)

<br/>

#### 캐시
- 데이터를 보관할 때 낡은 데이터는 자동적으로 소멸되도록 TTL을 설정하는 것이 바람직하다.
- 레디스(Redis)는 해당 상황에 적합하다.
- 요청 가운데 일부만 잔여 객실 데이터베이스가 처리하고 나머지는 캐시가 담당한다.
  - 예약 서비스: API 제공
  - 잔여 객실 캐시: 사전에 잔여 객실 정보를 캐시에 미리 저장해둔다.
  - 잔여 객실 데이터베이스: 잔여 객실 수에 대한 가장 신뢰성 있는 정보가 보관된다.
  - 👍 데이터베이스 부하가 크게 감소한다.
  - 👍 높은 성능을 보장한다.
  - 👎 데이터베이스와 캐시 사이의 데이터 일관성을 100% 유지하기는 어렵다.

<br/>

#### 서비스 간 데이터 일관성
- 데이터 일관성 문제를 해결하기 위해
  - 2단계 커밋(2PC): 여러 노드에 걸친 원자적 트랜잭션 실행을 보증하는 데이터베이스 프로토콜
    - 모든 노드가 성공하든 실패하든 둘 중 하나로 트랜잭션이 마무리되도록 보증한다.
    - 한 노드에 장애가 발생하면 복구될 때까지 진행이 중단된다.
    - 하나의 트랜잭션을 통해 ACID 속성을 만족시킨다.
   
  - 사가(Saga): 각 노드에 국지적으로 발생하는 트랜잭션을 하나로 엮은 것
    - 어느 한 트랜잭션이라도 실패하면 그 이전 트랜잭션의 결과를 전부 되돌리는 트랜잭션들을 순차적으로 실행한다.
    - 결과적 일관성에 의존한다.

<br/>

## 4️⃣ 마무리
- 개략적인 설계안
  - API 설계
  - 데이터 모델 초안
  - 시스템 아키텍처 다이어그램
 
- 상세 설계안
  - 데이터베이스 스키마 설계안 변경 (roomID -> roomTypeID)
  - 경쟁 조건 발생 조건 및 해결방안
  - 시스템 규모 확장 전략
    - 데이터베이스 샤등
    - 레디스 캐시
   
  - 데이터 일관성 문제
