# 3장 구글 맵
## 1️⃣ 문제 이해 및 설계 범위 확정
### 기능 요구사항
- 사용자 위치 갱신
- 경로 안내 서비스 (ETA 서비스 포함)
- 지도 표시

<br/>

### 비기능 요구사항 및 제약사항
- 정확도
- 부드러운 경로 표시
- 데이터 및 배터리 사용량 (최소)
- 일반적으로 널리 통용되는 가용성 및 규모 확장성 요구사항 만족

<br/>

### 지도 101
> **측위 시스템**

<img alt="image" width="300" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/ed872549-11ae-4e1d-8e51-9ad5b851245d"/>

🔼 위도와 경도
- **측위 시스템**은 구 표면 상의 위치를 표현하는 체계를 말한다.
- 위경도 기반 측위 시스템의 경우, 최상단에는 북극이 있고, 최하단에는 남극이 있다.
- 위도(Latitude)는 주어진 위치가 얼마나 북쪽/남쪽인지를 나타낸다.
- 경도(Longitude)는 얼마나 동쪽/서쪽인지를 나타낸다.

<br/>

> **3차원 위치의 2차원 변환**

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/2c527e8c-b4d9-4ff6-baea-7a8cd1a8a0ee"/>

🔼 지도 투영법 사이의 차이점
- 3차원 구 위의 위치를 2차원 평면에 대응시키는 절차를 **지도 투영법** 또는 **도법**이라 부른다.
- 거의 모든 투영법은 실제 지형의 기하학적 특성을 왜곡한다는 공통점을 갖는다.
- 구글 맵은 메르카토르 도법을 조금 변경한 **웹 메르카토르** 도법을 택하고 있다.

<br/>

> **지오코딩**

- **지오코딩**은 주소를 지리적 측위 시스템의 좌표로 변환하는 프로세스다.

<br/>

> **지오해싱**

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/a8640c1a-048c-4db9-8395-08909e64940c" />

🔼 지오해싱
- **지오해싱**은 지도 위 특정 영역을 영문자와 숫자로 구성된 짧은 문자열에 대응시키는 인코딩 체계다.
- 2차원의 평면 공간으로 표현된 지리적 영역 위의 격자를 더 작은 격자로 재귀적으로 분할해 나간다.

<br/>

> **지도 표시**

- 지도 전부를 하나의 이미지로 표시하는 대신, 작은 타일로 쪼개어 표시한다.
- 클라이언트는 현재 보려는 지도 확대 수준에 근거하여 어떤 크기의 타일을 가져올지 고른다.

<br/>

> **경로 안내 알고리즘을 위한 도로 데이터 처리**

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/99396d3a-adef-41e8-affb-1e8aafc6910d"/>

🔼 그래프로 표현한 지도
- 모든 경로 탐색 알고리즘은 교차로를 노드(node)로, 도로는 노드를 잇는 선(edge)으로 표현하는 그래프 자료 구조를 가정한다.
- 좋은 성능을 위해 그래프를 관리 기능 단위로 분할할 필요가 있다. (각 격자는 경로 안내 타일이라 부름)
- 도로망을 언제든 불러올 수 있는 경로 안내 타일로 분할해 놓으면 경로 탐색 알고리즘이 동작하는 데 필요한 메모리 요구량을 낮출 수 있고, 한번에 처리해야 하는 경로의 양이 줄어들며, 필요한만큼만 불러오면 되기 때문에 탐색 성능도 좋아진다.

<br/>

> **계층적 경로 안내 타일**

- 구체성 정도를 상, 중, 하로 구분하여 3가지 종류의 경로 안내 타일을 준비한다.
  - 가장 구체성이 높은 타일의 경우(**상**), 그 크기는 아주 작으며, 이런 타일에는 지방도 데이터만 둔다.
  - **중**은 더 넓은 지역을 커버하며, 규모가 비교적 큰 관할구를 잇는 간선 도로 데이터만 둔다.
  - 구체성이 가장 낮은 타일(**하**)은 그보다 더 큰 영역을 커버하며, 그런 타일에는 도시와 주를 연결하는 주요 고속 도로 데이터만 둔다.
 
<br/>

<img alt="image" width="300" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/03637ac0-6967-4808-b120-cc98ac2056aa" />

🔼 크기가 서로 다른 경로 안내 타일

<br/>

### 개략적 규모 추정

> **저장소 사용량**

- 세계 지도
  - 지도를 최대한 확대하여(zoom in) 보는 데 필요한 타일 개수를 따져보면 좋다.
  - 확대할 때마다 하나의 타일을 4장의 타일로 펼친다고 하면, 21번 최대 확대로 약 4.4조개의 파일이 필요하다.
  - 한 장의 타일이 압축 PNG 파일이라면 한 장당 100KB의 저장 공간이 필요하다.
  - 최대 확대 시 필요 타일을 전부 저장하려면 4.4조 * 100KB = 440PB만큼의 저장 공간이 필요할 것이다.
  - 지구 표면 가운데 90%는 인간이 살지 않는 자연 그대로임을 감안하면 44~88PB 가량으로 볼 수 있다. (어림잡아 50PB)
  - 다양한 확대 수준으로 지도를 표시하기 위해 대략 100PB 정도가 소요될 것이다.
 
- 메타데이터(metadata)
  - 크기가 아주 작아서 무시해도 지장이 없을 정도이다.
 
- 도로 정보
  - 요구사항을 통해 수 TB 용량의 도로 데이터를 보유하고 있음을 알 수 있다.
 
<br/>

> **서버 대역폭**

- 경로 안내 요청: QPS = 20만 (10억 DAU)
- 위치 갱신 요청: QPS = 200,000 * 5 = 1백만 (평균치의 5배 가량으로 가정)

<br/>

## 2️⃣ 개략적 설계안 제시 및 동의 구하기

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/a83e7114-aaee-48d4-b1ad-b8a72fca0c39"/>

🔼 개략적 설계안

<br/>

### 위치 서비스

<img alt="image" width="100" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/b8d9e987-a001-42c3-a80f-ee0a703c9fc6"/>

🔼 위치 서비스
- 위치 서비스는 사용자의 위치를 기록하는 역할을 담당한다.
- 클라이언트가 t초마다 자기 위치를 전송한다고 가정한다.
  - 👍 해당 데이터 스트림을 활용하여 시스템을 점차 개선할 수 있다.
  - 👍 클라이언트가 보내는 위치 정보가 거의 실시간 정보에 가까우므로 ETA를 좀 더 정확하게 산출할 수 있고, 교통 상황에 따라 다른 경로를 안내할 수도 있다.
 
<br/>

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/1706cf19-8f87-421a-bca5-26c5048f8327"/>

🔼 일괄 요청
- 위치 이력을 클라이언트에 버퍼링해 두었다가 일괄 요청하면 전송 빈도를 줄일 수 있다.

<br/>

- 아주 높은 쓰기 요청 빈도에 최적화되어 있고 규모 확장이 용이한 카산드라 같은 데이터베이스가 필요하다.
- 카프카 같은 스트림 엔진을 활용하여 위치 데이터를 로깅해야 할 수도 있다.
- 통신 프로토콜은 HTTP를 keep-alive 옵션과 함께 사용하면 효율을 높일 수 있을 것이다.
  ```
  POST /v1/locations
  인자:
  locs: JSON으로 인코딩한 (위도, 경도, 시각) 순서쌍 배열
  ```

<br/>

### 경로 안내 서비스
- 계산된 경로는 최단 시간 경로일 필요는 없으나 정확도는 보장되어야 한다.
- 사용자가 보낸 경로 안내 HTTP 요청은 로드밸런서를 거쳐 서비스에 도달한다.
  ```
  GET /v1/nav?origin=1355+market+street,SF&destination=Disneyland
  ```
  🔼 요청 예시<br/><br/>
  ```
  {
    'distance': {'text': '0.2mi', 'value': 259},
    'duration': {'text': '1 min1, 'value': 83},
    'end_location': {'lat': 37.4038943, 'Ing': -121.9410454},
    'html_instructions': 'Head <b>northeast</b> on <b>Brandon St</b>...',
    'polyline': {'points': '...'},
    'start_location': {'lat': 37.4027165, 'lng': -121.9435809},
    'geocoded_waypoints': [
      {
        "geocoder_status": "OK",
        "partial_match": true,
        "place_id": "...",
        "types": ["locality", "political"]
      },
      {
        "geocoder_status": "OK",
        "partial_match": true,
        "place_id": "...",
        "types": ["locality", "political"]
      }
    ],
    'travel_mode': 'DRIVING'
  }
  ```
  🔼 요청 결과 예시

<br/>

### 지도 표시
- 클라이언트는 언제 지도 타일을 서버에서 가져오는지 시나리오를 생각해볼 수 있다.
  - 사용자가 지도를 확대 또는 이동시키며 주변을 탐색한다.
  - 경로 안내가 진행되는 동안 사용자의 위치가 현재 지도 타일을 벗어나 인접한 타일로 이동한다.
 
- 다량의 지도 타일 데이터를 서버에서 효과적으로 가져오는 방법은 다음과 같다.
  - 클라이언트의 위치, 현재 클라이언트가 보는 지도의 확대 수준에 근거하여 필요한 지도 타일을 즉석에서 만든다.
    - 👎 심각한 부하가 걸릴 수 있다.
    - 👎 캐시를 활용하기 어렵다.
   
  - 확대 수준별로 미리 만들어 둔 지도 타일을 클라이언트에 전달하기만 한다.
    - 👍 규모 확장이 용이하고, 성능 측면에서도 유리하다.
    - 👍 지도 타일은 정적이므로 캐시를 통해 서비스하기 적합하다.
   
<br/>

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/37a0dc93-4632-47ce-b77f-47636b9cfce3"/>

🔼 CDN 기반 서비스 구조의 장점

<br/>

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/a32b1c95-9c5e-4c59-ba15-8872e5609f08"/>

🔼 지도 표시 흐름도
1. 모바일 사용자가 타일 URL들을 가져오기 위해 지도 타일 서비스를 호출한다. (로드밸런서로 전달)
2. 로드밸런서는 해당 요청을 지도 타일 서비스로 전달한다.
3. 지도 타일 서비스는 클라이언트의 위치와 확대 수준을 입력으로 삼아 9개의 타일 URL을 계산한 다음 클라이언트에 반환한다. 표시할 타일 하나와 8개의 주변 타일이 응답에 포함된다.
4. 모바일 클라이언트는 해당 타일을 CDN을 통해 다운로드한다.

<br/>

## 3️⃣ 상세 설계

### 데이터 모델

#### 경로 안내 타일
- 데이터 양이 방대하다.
- 객체 저장소(ex. S3)에 파일을 보관하고 그 파일을 이용할 경로 안내 서비스에서 적극적으로 캐싱한다.

<br/>

#### 사용자 위치 데이터
- 도로 데이터 및 경로 안내 타일을 갱신하거나, 실시간 교통 상황 데이터나 교통 상황 이력 데이터베이스를 구축하는 데 활용된다.
- 사용자 위치 데이터를 저장하려면 엄청난 양의 쓰기 연산을 잘 처리할 수 있으면서 수평적 규모 확장이 가능한 데이터베이스가 필요하다.
- **카산드라**는 해당 기준을 잘 만족시킬 수 있다.

<br/>

|user_id|timestamp|user_mode|driving_mode|location|
|--|--|--|--|--|
|101|1635740977|active|driving|(20.0, 30.5)|

🔼 사용자 위치 테이블

<br/>

#### 지오코딩 데이터베이스
- 주소를 위도/경도 쌍으로 변환하는 정보를 보관한다.
- 빠른 읽기 연산을 제공하는 키-값 저장소가 적당하다. (ex. 레디스)

<br/>

#### 미리 만들어 둔 지도 이미지
- 계산 자원이 많이 사용되고, 같은 이미지를 중복 요청하는 경우가 많다.
- 이미지는 한 번만 계산하고 그 결과는 캐시해 두는 전략을 쓰는 것이 좋다.
- 이미지는 지도 표시에 사용하는 확대 수준별로 미리 만들어 두고 CDN을 통해 전송한다.

<br/>

### 서비스

#### 위치 서비스

<img alt="image" width="200" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/af77eb35-fae8-4384-9c53-4a2b950eb2c7"/>

🔼 사용자 위치 데이터베이스
- 사용자 위치 데이터 저장에는 **키-값 저장소**를 활용한다.
- 초당 백만 건의 위치 정보 업데이트가 발생하므로 쓰기 연산 지원에 탁월한 데이터베이스가 필요하다.
  - NoSQL 키-값 데이터베이스
  - 열-중심 데이터베이스
 
- 데이터 일관성보다는 **가용성**이 더 중요하다. (가용성과 분할 내성을 만족시키는 데 집중)
- **카산드라**가 가장 적합하다.
  - 높은 가용성을 보장하면서도 막대한 규모의 연산을 감당할 수 있도록 해줄 것이다.
 
- 데이터베이스 키로는 `(user_id, timestamp)` 조합을 사용한다. (value = 위도/경도 쌍)
  - user_id : 파티션 키 (특정 사용자의 최근 위치를 신속히 읽어 내기 위함)
  - timestamp : 클러스터링 키 (정렬 기준)
 
<br/>

|key(user_id)|timestamp|lat|long|user_mode|navigation_mode|
|--|--|--|--|--|--|
|51|132053000|21.9|89.8|active|driving|

🔼 위치 데이터

<br/>

> **사용자 위치 데이터는 어떻게 이용되는가**

- 사용자 위치는 쓰임새가 다양한 중요 데이터다.
  - 새로 개설되었거나 폐쇄된 도로를 감지할 수 있다.
  - 지도 데이터의 정확성을 점차 개선하는 입력으로도 활용될 수 있다.
  - 실시간 교통 현황을 파악하는 입력이 될 수도 있다.
 
- 사용자 위치를 카프카와 같은 메시지 큐에 추가적으로 로깅한다.
  - Ex. 실시간 교통 상황 서비스는 해당 스트림을 통해 읽은 데이터로 실시간 교통량 데이터베이스를 갱신한다.
  - Ex. 경로 안내 타일 처리 서비스는 해당 데이터를 활용해 새로 열린 도로나 폐쇄된 도로를 탐지하고 해당 변경 내역을 객체 저장소의 경로 안내 타일에 반영함으로써 점진적으로 지도의 품질을 개선한다.
 
<br/>

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/d2d18099-eb6b-480d-9296-cbca3dd5cf98"/>

🔼 여러 서비스에 위치 데이터 제공

<br/>

#### 지도 표시

> **지도 타일 사전 계산**

- 확대 수준 0은 세계 전부를 256*256픽셀짜리 타일 하나로 표현한다.
- 확대 수준을 1단계 올릴 때마다 해당 수준을 위한 전체 타일 수는 동서 방향으로 2배, 남북 방향으로 2배 늘어난다.
  - 확대 수준 1: 필요한 타일 `2*2`장, 해당도 `512*512` 픽셀
  - 확대 수준 2: 필요한 타일 `4*4`장, 해상도 `1024*1024` 픽셀
 
- 클라이언트는 해당 정보를 제공하기 위한 타일을 다운 받는 데 많은 네트워크 대역폭을 소진하지 않고도 클라이언트에 설정된 확대 수준에 최적인 크기의 지도를 표시할 수 있다.

<br/>

> **최적화: 벡터 사용**

- 이미지 대신 경로와 다각형 등의 벡터 정보를 보낸다.
- 클라이언트는 수신된 경로와 다각형 정보를 통해 지도를 그려낸다.
- 이미지에 비해 월등한 압축률을 가지므로, 네트워크 대역폭을 많이 아낄 수 있다.
- 벡터화 된 이미지를 사용하면 클라이언트는 각 요소 크기를 적절하게 조정할 수 있어 훨씬 매끄러운 확대 경험을 제공할 수 있다.

<br/>

#### 경로 안내 서비스

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/696835ac-1cfd-4bbe-bd09-53d2bbff1864"/>

🔼 경로 안내 서비스

<br/>

> **지오코딩 서비스**

- 주소를 위도/경도 쌍으로 바꿔주는 서비스가 필요하다.
- 장소 이름으로 나타낸 주소도 있을 수 있고 지번 형태로 나타낸 주소도 있을 수 있다. (주의해야함)
- 경로 안내 서비스는 출발지와 목적지 주소를 위도/경도 쌍으로 변환한 뒤 추후 다른 서비스 호출에 이용한다.

<br/>

> **경로 계획 서비스**

- 최단 경로 서비스
  - 출발지와 목적지 위도/경도를 입력으로 받아 k개 최단 경로를 반환한다. (교통, 도로 상황 고려 X)
  - 객체 저장소에 저장된 경로 안내 타일에 대해 A* 경로 탐색 알고리즘의 한 형태를 실행한다.
    - 입력으로 출발지와 목적지의 위도/경도를 받는다.
    - 출발지 타일에서 시작하여 그래프 자료 구조를 탐색해 나간다.
   
- 예상 도착 시간 서비스
  - AI를 활용해 현재 교통 상황 및 과거 이력에 근거하여 예상 도착 시간을 계산한다.
 
- 순위 결정 서비스
  - 경로 계획 서비스는 ETA 예상치를 구하고 나면 순위 결정 서비스에 관련 정보를 모두 전달하여 사용자가 정의한 필터링 조건을 적용한다.
    - Ex. 유료 도로 제외, 고속도로 제외 등
   
  - 필터링이 끝나고 남은 경로를 소요 시간 순으로 정렬하여 최단 시간 경로 k개를 구한 다음 경로 안내 서비스에 결과를 반환한다.
 
<br/>

> **중요 정보 갱신 서비스들**

- 카프카 위치 데이터 스트림을 구독하고 있다가 중요 데이터를 비동기적으로 업데이트하여 그 상태를 항상 최신으로 유지하는 역할을 담당한다.
- **경로 안내 타일 처리 서비스**는 도로 데이터에 새로 발견된 도로, 폐쇄되었음이 확인된 도로 정보를 반영하여 경로 안내 타일을 지속적으로 갱신한다.
- **실시간 교통 상황 서비스**는 활성화 상태 사용자가 보내는 위치 데이터 스트림에서 교통 상황 정보를 추출한다.

<br/>

> **적응형 ETA와 경로 변경**

- 현 설계안은 적응형 ETA와 경로 변경을 허용하지 않는다.
- 이를 해결하기 위해 서버는 현재 경로 안내를 받고 있는 모든 사용자를 추적하면서 교통 상황이 달라질 때마다 각 사용자의 ETA를 변경해주어야 한다.
- 다음 중요한 질문이 있다.
  - 현재 경로 안내를 받고 있는 사용자는 어떻게 추적하나?
  - 수백만 경로 가운데 교통 상황 변화에 영향을 받는 경로와 사용자를 효율적으로 가려낼 방법은 무엇인가?
 
<br/>

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/ea63bc64-e925-4ba0-84ec-8d6272d4621e"/>

🔼 안내된 경로
- 간단하지만 효율적이지 않다.
- r_2에서 교통사고가 발생했다고 가정하자.
  - 레코드를 전수 조사해서 어떤 사용자가 해당 타일을 가지고 있는지 알아내야 한다.
  - 테이블에 보관된 레코드 수가 n이고 안내되는 경로의 평균 길이가 m이라면 교통 상황 변화에 영향 받는 모든 사용자 검색의 시간 복잡도는 O(n*m)이 된다.
 
<br/>

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/7dcbafc9-16f6-4850-8a5c-a031664863f1"/>

🔼 재귀적인 경로 타일 수집
- 경로 안내를 받는 사용자 각각의 현재 경로 안내 타일, 그 타일을 포함하는 상위 타일, 그 상위 타일의 상위 타일을 **출발지와 목적지가 모두 포함된 타일**을 찾을 때까지 재귀적으로 더하여 보관하는 것이다.
- 어떤 타일의 교통 상황이 변했을 때 경로 안내 ETA가 달라지는 사용자는, 해당 사용자의 데이터베이스 레코드 마지막 타일에 그 타일이 속하는 사용자다.
- 검색 시간 복잡도가 O(n)으로 줄어든다.
- 교통 상황이 개선되었을 때 해야 하는 일까지 해결해 주지 않는다.

<br/>

> **전송 프로토콜**

- 모바일 푸시 알림은 보낼 수 있는 메시지 크기가 매우 제한적이므로 사용하지 않는 게 바람직하다.
- **웹소켓**은 서버에 주는 부담이 크지 않아서 일반적으로 롱 폴링보다 좋은 방안으로 본다. (+ 양방향 통신 지원)

<br/>

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/cb3b9396-3530-4ae1-b58e-e125b8e28471"/>

🔼 최종 설계안

<br/>

## 4️⃣ 마무리
위치 갱신, ETA, 경로 계획, 지도 표시 등의 핵심 기능을 지원하는 단순화된 구글 맵 애플리케이션을 설계해 보았다.
