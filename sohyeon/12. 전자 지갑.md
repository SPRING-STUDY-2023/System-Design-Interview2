# 12장 전자 지갑

## 1️⃣ 문제 이해 및 설계 범위 확정

### 요구사항
- 전자 지갑 간 이체
- 1,000,000TPS
- 99.99%의 안정성
- 트랜잭션
- 재현성

<br/>

### 개략적 추정
- 1백만 TPS를 지원하기 위해 1,000개의 데이터베이스 노드가 필요하다.
- 단일 노드가 처리할 수 있는 트랜잭션 수를 늘리는 것이 중요하다.

<br/>

## 2️⃣ 개략적 설계안 제시 및 동의 구하기

### API 설계
- 한 지갑에서 다른 지갑으로 자금 이체
  - POST /v1/wallet/balance_transfer
 
<br/>

### 인메모리 샤딩
- 클러스터를 구성하고 사용자 계정을 모든 노드에 균등하게 분산시켜야 한다. (파티셔닝 or 샤딩)
- 지갑 서비스 (이체 명령 서비스)
  1. 이체 명령의 수신
  2. 이체 명령의 유효성 검증
  3. 명령이 유효한 것으로 확인되면 이체에 관계된 두 계정의 잔액 갱신. 이 두 계정은 서로 다른 레디스 노드에 있을 수 있다.
 
<br/>

### 분산 트랜잭션
- 데이터베이스 샤딩: 각 레디스 노드를 트랜잭션을 지원하는 관계형 데이터베이스 노드로 교체한다.
- 분산 트랜잭션: 2단계 커밋
  - 저수준 방안: 데이터베이스 자체에 의존

- 분산 트랜잭션: TC/C(Try-Confirm/Cancel) (보상 기반 분산 트랜잭션)
- 단계별 상태 테이블
  - 분산 트랜잭션의 ID와 내용
  - 각 데이터베이스에 대한 시도(Try) 단계의 상태 : not sent yet, has been sent, response received
  - 두 번째 단계의 이름 : Confirm, Cancel
  - 두 번째 단계의 상태
  - 순서가 어긋났음을 나타내는 플래그
 
- 불균형 상태
  - 분산 트랜잭션 실행 중에는 항상 데이터 불일치가 발생한다.
 
- 유효한 연산 순서
  1. 계정A (-1$) | 계정C (NOP)
  2. 계정A (NOP) | 계정C (+1$) (트랜잭션 보증 위반)
  3. 계정A (-1$) | 계정C (+1$) (트랜잭션 보증 위반)
 
- 잘못된 순서로 실행된 경우
  - TC/C에는 실행 순서가 어긋날 수 있다는 문제가 있다.
 
- 분산 트랜잭션: 사가
  - 선형적 명령 수행
    1. 모든 연산은 순서대로 정렬된다.
    2. 연산은 첫번째부터 마지막까지 순서대로 실행된다.
    3. 연산이 실패하면 전체 프로세스는 실패한 연산부터 맨 처음 연산까지 역순으로 보상 트랜잭션을 통해 롤백된다.
   
<br/>

### 이벤트 소싱
- 명령
  - 외부에서 전달된, 의도가 명확한 요청
  - FIFO 큐에 저장된다.
 
- 이벤트
  - 명령 이행 결과
  - 이벤트 순서는 명령 순서를 따라야 함 (FIFO 큐에 저장)
 
- 상태
  - 이벤트가 적용될 때 변경되는 내용
  - 키-값 저장소 사용
 
- 상태 기계
  - 명령의 유효성을 검사하고 이벤트 생성
  - 이벤트를 적용하여 상태 갱신
 
<br/>

### 재현성
- 이벤트를 처음부터 다시 재생하면 과거 잔액 상태는 언제든 재구성할 수 있다.
- 이벤트 리스트는 불변이고 상태 기계 로직은 결정론적이므로 이벤트 이력을 재생하여 만들어낸 상태는 언제나 동일하다.

<br/>

### 명령, 질의 책임 분리 (CQRS)
- 이벤트를 수신하는 외부 주체가 직접 상태를 재구축할 수 있다.
- 읽기 전용 상태 기계는 이벤트 큐에서 다양한 상태 표현을 도출할 수 있다.

<br/>

## 3️⃣ 3단계

### 고성능 이벤트 소싱
- 파일 기반의 명령 및 이벤트 목록
  - 명령과 이벤트를 로컬 디스크에 저장한다.
  - 최근 명령과 이벤트를 메모리에 캐시한다.
  - nmap을 사용하면 로컬 디스크에 쓰는 동시에, 최근 데이터는 메모리에 자동으로 캐시할 수 있다.
 
- 파일 기반 상태
  - 상태 정보도 로컬 디스크에 저장할 수 있다.
  - SQLite를 사용하거나, RocksDB를 사용할 수도 있다.
 
- 스냅샷
  - 주기적으로 상태 기계를 멈추고 현재 상태를 파일에 저장한다면 시간을 절약할 수 있다.
  - 거대한 이진 파일로, 일반적으로 HDFS와 같은 객체 저장소에 저장된다.
 
<br/>

### 신뢰할 수 있는 고성능 이벤트 소싱
- 신뢰성 분석
  1. 파일 기반 명령
  2. 파일 기반 이벤트
  3. 파일 기반 상태
  4. 상태 스냅샷
 
- 합의
  1. 데이터 손실 없음
  2. 로그 파일 내 데이터의 상대적 순서는 모든 노드에 동일

- 고신뢰성 솔루션
  - 리더에 장애가 발생하면 래프트 알고리즘은 나머지 정상 노드 중에서 새 리더를 선출한다.
  - (요청 중 오류가 발생한다면) 클라이언트는 새로 선출된 리더에게 같은 명령을 다시 보내야 한다.
  - 래프트는 죽은 노드가 다시 시작되거나 새로운 노드로 대체될 때까지 기한 없이 재시도하여 해당 장애를 처리한다.
 
<br/>

### 분산 이벤트 소싱
- 풀 vs 푸시
  - 풀 모델에서는 외부 사용자가 읽기 전용 상태 기계에서 주기적으로 실행 상태를 읽는다. (역방향 프록시로 과부하 문제 해결 가능)
  - 읽기 전용 상태 기계로 하여금 이벤트를 수신하자마자 실행 상태를 역방향 프록시에 푸시하도록 하면 실시간 응답처럼 보이게 할 수 있다.
 
- 분산 트랜잭션
  - 모든 이벤트 소싱 노드 그룹이 동기적 실행 모델을 채택하면 TC/C나 사가 같은 분산 트랜잭션 솔루션을 재사용할 수 있다.
 
<br/>

## 4️⃣ 마무리
- 인메모리 키-값 저장소를 사용하는 솔루션 (내구성X)
- 인메모리 캐시를 트랜잭션 데이터베이스로 대체 (데이터 감사의 어려움)
- 이벤트 소싱 방안 (성능 저하)
- 래프트 합의 알고리즘을 사용하여 이벤트 목록을 여러 노드에 복제하는 방안 도입 (안정성 향상)
- 이벤트 소싱에 CQRS 도입 (비동기 가능, 역방향 프록시 추가)

<br/>

