# 12장 전자 지갑

## 1️⃣ 문제 이해 및 설계 범위 확정

### 요구사항
- 전자 지갑 간 이체
- 1,000,000TPS
- 99.99%의 안정성
- 트랜잭션
- 재현성

<br/>

### 개략적 추정
- 1백만 TPS를 지원하기 위해 1,000개의 데이터베이스 노드가 필요하다.
- 단일 노드가 처리할 수 있는 트랜잭션 수를 늘리는 것이 중요하다.

<br/>

## 2️⃣ 개략적 설계안 제시 및 동의 구하기

### API 설계
- 한 지갑에서 다른 지갑으로 자금 이체
  - POST /v1/wallet/balance_transfer
 
<br/>

### 인메모리 샤딩
- 클러스터를 구성하고 사용자 계정을 모든 노드에 균등하게 분산시켜야 한다. (파티셔닝 or 샤딩)
- 지갑 서비스 (이체 명령 서비스)
  1. 이체 명령의 수신
  2. 이체 명령의 유효성 검증
  3. 명령이 유효한 것으로 확인되면 이체에 관계된 두 계정의 잔액 갱신. 이 두 계정은 서로 다른 레디스 노드에 있을 수 있다.
 
<br/>

### 분산 트랜잭션
- 데이터베이스 샤딩: 각 레디스 노드를 트랜잭션을 지원하는 관계형 데이터베이스 노드로 교체한다.
- 분산 트랜잭션: 2단계 커밋
  - 저수준 방안: 데이터베이스 자체에 의존

- 분산 트랜잭션: TC/C(Try-Confirm/Cancel) (보상 기반 분산 트랜잭션)
- 단계별 상태 테이블
  - 분산 트랜잭션의 ID와 내용
  - 각 데이터베이스에 대한 시도(Try) 단계의 상태 : not sent yet, has been sent, response received
  - 두 번째 단계의 이름 : Confirm, Cancel
  - 두 번째 단계의 상태
  - 순서가 어긋났음을 나타내는 플래그
 
- 불균형 상태
  - 분산 트랜잭션 실행 중에는 항상 데이터 불일치가 발생한다.
 
- 유효한 연산 순서
  1. 계정A (-1$) | 계정C (NOP)
  2. 계정A (NOP) | 계정C (+1$) (트랜잭션 보증 위반)
  3. 계정A (-1$) | 계정C (+1$) (트랜잭션 보증 위반)
 
- 잘못된 순서로 실행된 경우
  - TC/C에는 실행 순서가 어긋날 수 있다는 문제가 있다.
 
- 분산 트랜잭션: 사가
  - 선형적 명령 수행
    1. 모든 연산은 순서대로 정렬된다.
    2. 연산은 첫번째부터 마지막까지 순서대로 실행된다.
    3. 연산이 실패하면 전체 프로세스는 실패한 연산부터 맨 처음 연산까지 역순으로 보상 트랜잭션을 통해 롤백된다.
   
<br/>

### 이벤트 소싱
- 명령
  - 외부에서 전달된, 의도가 명확한 요청
  - FIFO 큐에 저장된다.
 
- 이벤트
  - 명령 이행 결과
  - 이벤트 순서는 명령 순서를 따라야 함 (FIFO 큐에 저장)
 
- 상태
  - 이벤트가 적용될 때 변경되는 내용
  - 키-값 저장소 사용
 
- 상태 기계
  - 명령의 유효성을 검사하고 이벤트 생성
  - 이벤트를 적용하여 상태 갱신
 
<br/>

### 재현성
- 이벤트를 처음부터 다시 재생하면 과거 잔액 상태는 언제든 재구성할 수 있다.
- 이벤트 리스트는 불변이고 상태 기계 로직은 결정론적이므로 이벤트 이력을 재생하여 만들어낸 상태는 언제나 동일하다.

<br/>

### 명령, 질의 책임 분리 (CQRS)
- 이벤트를 수신하는 외부 주체가 직접 상태를 재구축할 수 있다.
- 읽기 전용 상태 기계는 이벤트 큐에서 다양한 상태 표현을 도출할 수 있다.

<br/>

## 3️⃣ 3단계
