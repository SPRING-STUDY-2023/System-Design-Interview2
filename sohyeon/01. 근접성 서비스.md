# 1장 근접성 서비스

## 1️⃣ 문제 이해 및 설계 범위 확정

### 기능 요구사항
- 사용자의 위치(경도, 위도)와 검색 반경 정보에 매치되는 사업장 목록을 반환한다.
- 사업장 소유주가 사업장 정보를 추가/삭제/갱신할 수 있도록 하되, 그 정보가 검색 결과에 실시간으로 반영될 필요는 없다고 가정한다.
- 고객은 사업장의 상세 정보를 살필 수 있어야 한다.

<br/>

### 비기능 요구사항
- **낮은 응답 지연(latency)**: 사용자는 주변 사업장을 신속히 검색할 수 있어야 한다.
- **데이터 보호(data privacy)**: 사용자 위치는 민감한 정보다. 데이터 사생활 보호 법안을 준수하도록 한다.
- **고가용성(high availiability) 및 규모 확장성(scalability) 요구사항**: 인구 밀집 지역에서 이용자가 집중되는 시간에 트래픽이 급증해도 감당할 수 있도록 시스템을 설계해야 한다.

<br/>

### 개략적 규모 추정
- 일간 능동 사용자(DAU) : 1억명
- 등록된 사업장 수 : 2억
- 1일은 대략 10^5로 올림하여 계산하기 쉽게 사용하도록 한다. (1일 = 24시간 * 60분 * 60초 = 86,400초)
- 한 사용자는 하루에 5회 검색을 시도한다고 가정한다.
- **QPS(Query per Second)** = (1억 * 5) / 10^5 = **5,000**

<br/>

## 2️⃣ 개략적 설계안 제시 및 동의 구하기

### API 설계

> **GET /v1/search/nearby**

- 특정 검색 기준에 맞는 사업장 목록을 반환한다.
- API 호출 시 전달한 인자는 아래와 같다.
  |필드|설명|자료형|
  |---|---|---|
  |latitude|검색할 위도|decimal|
  |longitude|검색할 경도|decimal|
  |radius|optional, 기본값은 5000m|int|
- 반환되는 결과는 아래 형태와 같다.
  ```
  {
    "total": 10,
    "business": [{business object}]
  }
  ```
  - `business`: 각 사업장을 표현하는 객체

<br/>

> **사업장 관련 API**

|API|설명|
|---|---|
|GET /v1/business/:id|특정 사업장의 상세 정보 반환|
|POST /v1/business|새로운 사업장 추가|
|PUT /v1/business/:id|사업장 상세 정보 갱신|
|DELETE /v1/business/:id|특정 사업장 정보 삭제|

<br/>

### 데이터 모델

> **읽기/쓰기 비율**

- 읽기 연산은 자주 수행된다. 아래 2개 기능의 이용 빈도가 높다.
  - 주변 사업장 검색
  - 사업장 정보 확인
 
- 쓰기 연산 실행 빈도는 낮다. 사업장 정보를 추가/삭제/편집하는 행위는 빈번하지 않기 때문이다.

<br/>

> **데이터 스키마**

- business 테이블<br/><br/>
  <img alt="image" width="200" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/776ee06f-7014-4dea-a51e-a18d9fe66a17" />

- 지리적 위치 색인 테이블
  - 위치 정보 관련 연산의 효율성을 높이는 데 쓰인다.

<br/>

### 개략적 설계안

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/03141718-7d16-4589-abb6-ab29c0216f69" />

🔼 개략적 설계안

<br/>

> **로드밸런서**

- 유입 트래픽을 자동으로 여러 서비스에 분산시키는 컴포넌트
- 통상적으로 로드밸런서에 단일 DNS 진입점을 지정하고, URL 경로를 분석하여 어느 서비스에 트래픽을 전달할지 결정한다.

<br/>

> **위치 기반 서비스(LBS)**

- 주어진 위치와 반경 정보를 이용해 주변 사업장을 검색한다.
- 쓰기 요청이 없는, 읽기 요청만 빈번하게 발생하는 서비스이다.
- QPS가 높다. 특히 특정 시간대의 인구 밀집 지역일수록 그 경향이 심하다.
- 무상태 서비스이므로 수평적 규모 확장이 쉽다.

<br/>

> **사업장 서비스**

- 사업장 소유주가 사업장 정보를 생성/갱신/삭제한다. 기본적으로 쓰기 요청이며, QPS는 높지 않다.
- 고객이 사업장 정보를 조회한다. 특정 시간대에 QPS가 높아진다.

<br/>

> **데이터베이스 클러스터**

- 주-부(primary-secondary) 데이터베이스 형태로 구성할 수 있다.
  - 주 데이터베이스: 쓰기 요청 처리
  - 부 데이터베이스: 읽기 요청 처리
- 데이터는 일단 주 데이터베이스에 기록된 다음에 사본(부) 데이터베이스로 복사된다.
  - 실시간으로 갱신될 필요가 없기 때문에, 주와 사본 사이의 시간 차는 큰 문제가 되지 않는다.
 
<br/>

> **사업장 서비스와 LBS의 규모 확장성**

- 점심시간 등의 특정 시간대에 집중적으로 몰리는 트래픽에는 자동으로 서버를 추가하여 대응하고, 야간 등 유휴 시간 대에는 서버를 삭제하도록 구성할 수 있다.
- 시스템을 클라우드에 둔다면 여러 지역, 여러 가용성 구역에 서버를 두어 시스템 가용성을 높일 수 있다.

<br/>

### 주변 사업장 검색 알고리즘
- 주변 사업장 검색 방법들을 살펴본다.

<br/>

### 방안1: 2차원 검색

- 주어진 반경으로 그린 원 안에 놓인 사업장을 검색하는 방법이다.
- 직관적이지만 지나치게 단순하다.
- 유사 SQL 질의문은 아래와 같다.
  ```
  SELECT business_id, latitude, longitude
  FROM business
  WHERE (latitude BETWEEN {:my_lat} - radius AND {:my_lat} + radius)
    AND (longitude BETWEEN {:my_long} - radius AND {:my_long} + radius)
  ```
  - 테이블을 전부 읽어야 하므로 효율적이지 않다.
  - 위도와 경도 각 집합에 속한 데이터의 양이 엄청나다.
  - 색인(index)은 오직 한 차원의 검색 속도만 개선할 수 있다. (위치는 2차원)
  - 따라서 **2차원 데이터를 한 차원에 대응**시키면 개선이 가능하다.

<br/>

<img alt="image" width="600" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/864d601d-7cef-4e20-a11e-5141eada7629" />

🔼 지리적 정보 색인 방안 유형
- 지도를 작은 영역으로 분할하고 고속 검색이 가능하도록 색인을 만든다.
- **해시 기반 방안**: 균등 격자, 지오해시, 카르테시안 계층 등
- **트리 기반 방안**: 쿼드트리, 구글 S2, R 트리 등

<br/>

### 방안2: 균등 격자

- 지도를 작은 격자 또는 구획으로 나누는 단순한 접근법이다.
- 하나의 격자는 여러 사업장을 담을 수 있고, 하나의 사업장은 오직 한 격자 안에만 속한다.
- 👎 사업장 분포가 균등하지 않다.
- 👎 주어진 격자의 인접 격자를 찾기가 까다로울 수 있다.

<br/>

### 방안3: 지오해시(Geohash)

- 2차원의 위도 경도 데이터를 1차원의 문자열로 변환한다.
- 비트를 하나씩 늘려가면서 재귀적으로 세계를 더 작은 격자로 분할해간다.
- 개략적인 과정은 아래와 같다.
  1. 전 세계를 자오선과 적도 기준 사분면으로 나눈다. <br/>
      <img alt="image" width="200" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/a594ee0f-f05d-439d-a1cd-b9dd59ddc6f6" />
     - 위도 범위 [-90, 0]은 0에 대응
     - 위도 범위 [0, 90]은 1에 대응
     - 경도 범위 [-180, 0]은 0에 대응
     - 경도 범위 [0, 180]은 1에 대응 <br/>
  2. 각각의 격자를 또 다시 사분면으로 나눈다. (이때 각 격자는 경도와 위도 비트를 앞서 살펴본 순서대로 반복하여 표현함)
  3. 이 절차를 원하는 정밀도를 얻을 때까지 반복한다. (통상적으로 base32 표현법을 사용)<br/>
      <img alt="image" width="200" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/88e4d5ae-8ca2-4ef2-ba07-2ba3bd0c46d6" />
      - 구글 본서 지오해시: 1001 11010 01001 10001 11111 11110 (base32 이진 표기), 9q9hvu (base32)
      - 페이스북 본사 지오해시: 1001 11010 01001 10011 10001 11011 (base32 이진 표기), 9q9jhr (base32)
- 12단계 정밀도를 갖는다. (정밀도가 격자 크기를 결정)
- 최적 정밀도: 사용자가 지정한 반경으로 그린 원을 덮는 최소 크기 격자를 만드는 지오해시 길이
- 격자 가장자리 처리 방식에 관한 경계 조건이 몇 가지 있다.
  - **격자 가장자리 관련 이슈1**: 아주 가까운 두 위치가 어떤 공통 접두어도 갖지 않는 일이 발생할 수 있다. (지구는 둥그니까 🌏)
  - **격자 가장자리 관련 이슈2**: 두 지점이 공통 접두어 길이는 길지만 서로 다른 격자에 놓일 수 있다. (인접한 모든 격자를 가져와 해결 가능)
  - **표시할 사업장이 충분하지 않은 경우**: 주어진 반경 내 사업장만 반환하거나, 검색 반경을 키워 해결할 수 있다.
 
<br/>

### 방안4: 쿼드트리

- 격자의 내용이 특정 기준을 만족할 때까지 2차원 공간을 재귀적으로 사분면 분할하는 데 흔히 사용되는 자료 구조다.
- 메모리 안에 놓이는 자료 구조일 뿐, 데이터베이스는 아니다.
- 각각의 LBS 서버에 존재해야 하며, 서버가 시작하는 시점에 구축된다.

<br/>

<img width="500" alt="image" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/fa184eab-a06c-4940-8ad2-086c39b58f26">

🔼 쿼드트리
- 세계를 쿼드트리를 사용해 분할하는 과정을 개념적으로 요약한 이미지다.
- 전 세계에 200m(2백만)개의 사업장이 있다고 가정했다.

<br/>

<img width="600" alt="image" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/b0ea1e28-1b11-4096-a8da-a27179dbdbee">

🔼 쿼드트리 구축
- 위 과정을 좀 더 자세하게 시각화한 것이다.
- 트리의 루트 노드는 세계 전체 지도를 나타낸다.
- 루트 노드를 사분면 각각을 나타내는 하위 노드로, 어떤 노드의 사업장도 100개(임시값)를 넘지 않을 때까지 재귀적으로 분할한다.
- 해당 과정을 수도코드로 나타내면 아래와 같다.
  ```
  public void buildQuadtree(TreeNode node) {
    if (countNumberOfBusinessInCurrentGrid(node) > 100) {
      node.subdivide();
      for (TreeNode child : node.getChilderen()) {
        buildQuadtree(child);
      }
    }
  }
  ```

<br/>

> **쿼드트리 전부를 저장하는 데 얼마나 많은 메모리가 필요한가?**

|이름|크기|
|---|---|
|격자를 식별하는 데 사용될 좌상단과 우하단 꼭짓점 좌표|32바이트(8바이트 * 4)|
|격자 내부 사업장 ID 목록|ID당 8바이트 * 100 (한 격자에 허용되는 사업장 수의 최댓값)|
|합계|832바이트|

🔼 말단 노드에 수록되는 데이터

<br/>

|이름|크기|
|---|---|
|격자를 식별하는 데 사용될 좌상단과 우하단 꼭짓점 좌표|32바이트(8바이트 * 4)|
|하위 노드 4개를 가리킬 포인터|32바이트(8바이트 * 4)|
|합계|64바이트|

🔼 내부 노드에 수록되는 데이터

<br/>

- 격자 안에는 최대 100개 사업장이 있을 수 있다.
- 말단 노드의 수 =~ 200m/100 =~ 2m(2백만)
- 내부 노드의 수 = 2m * 1/3 =~ 0.67m
- 총 메모리 요구량 = 2m * 832바이트 + 0.67m * 64바이트 =~ 1.71GB (👍 요구량이 꽤 작음)

<br/>

> **전체 쿼드트리 구축에 소요되는 시간은?**

- 각 말단 노드에는 대략 100개의 사업장 ID가 저장되고, 전체 사업장 수를 n이라고 한다.
- 트리를 구축하는 시간 복잡도는 `n/100 log n/100`이다.
- 200m개의 사업장 정보를 인덱싱하는 쿼드트리 구축에는 몇 분 정도가 소요될 수 있다.

<br/>

> **쿼드트리로 주변 사업장을 검색하려면?**

1. 메모리에 쿼드트리 인덱스를 구축한다.
2. 검색 시작점이 포함된 말단 노드를 만날 때까지, 트리의 루트 노드부터 탐색한다. 해당 노드에 100개 사업장이 있는 경우에는 해당 노드만 반환한다. 그렇지 않은 경우에는 충분한 사업장 수가 확보될 때까지 인접 노드도 추가한다.

<br/>

> **쿼드트리 운영 시 고려사항**

- 서버를 시작하는 순간에 트리를 구축하면 서버 시작 시간이 길어질 수 있다.
  - 새로운 버전의 서버 소프트웨어를 릴리즈할 때는 동시에 너무 많은 서버에 배포하지 않도록 조심해야 한다.
 
- 사업장이 추가/삭제되었을 때 쿼드트리를 갱신하는 문제를 고려해야 한다.
  - 점진적으로 갱신한다. (갱신 중 낡은 데이터가 반환될 수 있음)
  - 새로 갱신된 정보는 다음날 반영한다. (일괄 캐시하여 막대한 부하가 가해질 수 있음)
  - 실시간으로 갱신한다. (락 메커니즘을 사용하는 등 설계가 복잡해짐)
 
<br/>

> **실제로 쓰이는 쿼드트리 사례**

- 엑스트(Yext)가 제공한 덴버(Denver) 인근 쿼드트리 구축 사례를 보면,
  - 인구 밀집 지역에는 작은 격자를,
  - 그렇지 않은 지역에는 큰 격자를 사용한다.
 
<br/>

### 방안5: 구글 S2

- 메모리 기반(in-memory)이다.
- 지구를 힐베르트 곡선이라는 공간 채움 곡선을 사용하여 1차원 색인화한다.
  - 힐베르트 곡선 상에서 인접한 두 지점은 색인화 이후 1차원 공간 내에서도 인접한 위치에 있다.
 
<br/>

![image](https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/20b50ecb-f9cc-42c5-bce5-e7c0d520d3f2)

🔼 힐베르트 곡선
- 구글이나 틴더(Tinder) 같은 회사에서 널리 쓰인다.
- 👍 다양한 수준의 영역 지정이 가능하다.
  - `특정 지점 반경 몇 km 이내`같은 식으로 동적 지정 가능
  - 스쿨 존이나 동네 경계처럼 이미 존재하는 경계선들을 묶어 설정 가능)
- 👍 영역 지정 알고리즘을 지원하여 S2가 반환하는 결과가 좀 더 상세하다.
  - 최소 수준, 최고 수준, 그리고 최대 셀 개수 등을 지정할 수 있다.
 
<br/>

### 추천

|색인 방법|회사|
|---|---|
|지오해시|빙 지도, 레디스, 몽고DB, 리프트|
|쿼드트리|엑스트|
|지오해시 + 쿼드트리|Elasticsearch|
|S2|구글 맵, 틴더|

🔼 지리 정보 색인 기술 사용 현황

<br/>

### 지오해시 vs 쿼드트리

>**지오해시**

- 👍 구현과 사용이 쉽다. (트리 구축X)
- 지정 반경 이내 사업장 검색을 지원한다.
- 👎 정밀도를 고정하면 격자 크기도 고정된다. (인구 밀도에 따라 동적으로 격자 크기를 조정할 수 없음)
- 👍 색인 갱신이 쉽다. (사업장 하나를 삭제하면, 지오해시 값과 사업장 식별자가 같은 열 하나를 제거하면 됨)

<br/>

>**쿼드트리**

- 👎 구현하기가 상대적으로 까다롭다. (트리 구축 필요)
- 👍 k번째로 가까운 사업장까지의 목록을 구할 수 있다. (노드 분할 과정)
- 👍 인구 밀도에 따라 격자 크기를 동적으로 조정할 수 있다.
- 👎 지오해시보다 색인 갱신은 까다롭다.
  - 사업장 하나를 삭제하면, 루트 노드부터 말단 노드까지 트리를 순회해야 함 (시간복잡도 O(log n))
  - 다중 스레드를 지원하는 경우에는 락(lock)을 사용해야 하기 때문에 구현은 더 복잡해진다.
  - 말단 노드에 새로운 사업장을 추가할 수 없는 경우 리밸런싱이 필요해서 복잡해진다. (말단 노드가 담당해야 하는 구간의 크기를 필요한 양보다 크게 잡으면 어느정도 해결됨)
 
<br/>
