# 10장 실시간 게임 순위표

## 1️⃣ 문제 이해 및 설계 범위 확정

### 기능 요구사항
- 순위표에 상위 10명의 플레이어를 표시한다.
- 특정 사용자의 순위를 표시한다.
- 어떤 사용자보다 4순위 위와 아래에 있는 사용자를 표시한다. (보너스 문제)

<br/>

### 비기능 요구사항
- 점수 업데이트는 실시간으로 순위표에 반영한다.
- 일반적인 확장성, 가용성 및 안정성 요구사항

<br/>

### 개략적 규모 추정
- 초당 평균 50명의 사용자가 게임을 플레이
  - 24시간동안 게임 중인 사용자 수가 고르게 분포된다고 가정
  - DAU가 500만 명으로 가정
 
- 최대 250명의 사용자를 감당할 수 있어야 함
  - 최대 부하는 평균의 5배로 가정
 
- 사용자 점수 획득 QPS: 500가량
  - 한 사용자가 하루 평균 10개의 게임을 플레이한다고 가정

- 최대 QPS: 2500가량
  - 500 * 5 (최대 부하 5배)
 
- 상위 10명 순위표 가져오기 QPS: 약 50
  - 각 사용자가 하루에 한 번 게임을 연다고 가정
  - 상위 10명 순위표는 사용자가 처음 게임을 열 때만 표시한다고 가정
 
<br/>

## 2️⃣ 개략적 설계안 제시 및 동의 구하기

### API 설계
- POST /v1/scores
  - 사용자가 게임에서 승리하면 순위표에서 사용자의 순위를 갱신한다.
 
- GET /v1/scores
  - 순위표에서 상위 10명의 플레이어를 가져온다.
 
- GET /v1/scores/{:user_id}
  - 특정 사용자의 순위를 가져온다.
 
<br/>

### 개략적 설계안
- 게임 서비스는 사용자가 게임을 플레이할 수 있도록 한다.
- 순위표 서비스는 순위표를 생성하고 표시하는 역할을 담당한다.

<br/>

<img alt="image" width="500" src="https://github.com/user-attachments/assets/e50e384f-d7bb-4504-8b53-bd1ca5ec7d29"/>

- 클라이언트가 순위표 서비스와 직접 통신해야 하나?
  - 위 방식은 클라이언트가 점수를 정한다.
  - 👎 중간자 공격이 가능해 보안상 안전하지 않다.
  - 점수는 서버가 설정해야 한다.

    <img alt="image" width="400" src="https://github.com/user-attachments/assets/8d13a09f-b884-42a4-9beb-03f4103839cd" />

- 게임 서비스와 순위표 서버 사이에 메시지 큐가 필요한가?
  - 해당 데이터가 다른 곳에서도 이용되거나 여러 기능을 지원해야 한다면 카프카에 데이터를 넣는 것이 합리적일 수 있다.

    <img alt="image" width="400" src="https://github.com/user-attachments/assets/f147e78e-b6d0-4d95-8262-852140509817"/>

<br/>

### 데이터 모델

#### 관계형 데이터베이스
- 규모 확장성이 크게 중요하지 않고 사용자 수가 많지 않은 경우에 좋다.
- 사용자가 점수를 딴 경우
  - 해당 월의 순위표에 해당 사용자의 레코드가 없다면 새로운 레코드를 만들어 넣는다.
  - 이미 레코드가 있는 경우 점수 데이터를 갱신한다.
 
- 특정 사용자 순위 검색
  - 순위표 테이블을 점수 기준으로 정렬한 다음 순위를 매긴다.
 
- 관계형 데이터베이스는 본 시스템에 요구되는 다량의 읽기 부하를 처리하기 어렵다.

<br/>

#### 레디스
- 메모리에서 동작하므로 빠른 읽기 및 쓰기가 가능하다.
- 순위표 시스템 설계 문제를 해결하는 데 이상적인 정렬 집합(sorted set) 자료형을 제공한다.
- 레디스 정렬 집합을 사용한 구현
  - ZADD: 기존에 없던 사용자를 집합에 삽입한다.
  - ZINCRBY: 사용자 점수를 지정된 값만큼 증가시킨다.
  - ZRANGE/ZREVRANGE: 점수에 따라 정렬된 사용자 중에 특정 범위에 드는 사용자들을 가져온다.
  - ZRANK/ZREVRANK: 오름차순/내림차순 정렬하였을 때 특정 사용자의 위치를 가져온다.
 
<br/>

#### 저장소 요구사항
- 최소한 사용자 ID와 점수는 저장해야 한다.
- 최악의 시나리오를 가정하면 약 650MB의 저장공간이 레디스 캐시에 필요하다. (26바이트 * 2,500만)
  - 순위표 한 항목당 26바이트가 필요
 
- 보통 레디스에 읽기 사본을 두는 식으로 구성한다.
- 관계형 테이블을 사용할 경우 2개의 테이블(사용자 및 점수)이 필요하다.
  - 경연 기록과 같은 다른 게임 기능 구현에 활용할 수 있다.
  - 인프라 장애 발생 시 레디스 순위표를 복구하는 데에도 활용할 수 있다.
 
- 최적의 방안은 가장 자주 검색되는 상위 10명의 사용자 정보를 캐시하는 것이다.
 
<br/>

## 3️⃣ 상세 설계

### 클라우드 서비스 사용 여부
#### 자체 서비스를 이용하는 방안
- 매월 정렬 집합을 생성하여 해당 기간의 순위표를 지정한다.
- 순위표를 가져올 때 API 서버는 순위 데이터와 더불어 데이터베이스에 저장된 사용자 이름과 프로필 이미지도 가져온다.

<img alt="image" width="500" src="https://github.com/user-attachments/assets/d6ff9739-3beb-4aa6-9d4a-a72906e67140"/>

<br/>

#### 클라우드 서비스를 이용하는 방안
- 아마존 API 게이트웨이, AWS 람다를 사용한다.
  - `AWS 람다`: 서버를 직접 준비하거나 관리할 필요 없이 코드를 실행할 수 있다.
 
- API 게이트웨이를 호출하고, 게이트웨이는 적절한 람다 함수를 호출한다.
- 람다를 사용하면 DAU 성장세에 맞춰 자동으로 서비스 규모를 확장할 수 있다.

<img alt="image" width="500" src="https://github.com/user-attachments/assets/9d0444c2-d27d-4fa0-b766-2e0676bb45cc"/>

<br/>

### 레디스의 규모 확장 문제
- 최악의 경우 250,000QPS의 질의를 처리할 수 있어야 한다.
- 규모를 감당하기 위해 샤딩이 필요하다.

<br/>

#### 데이터 샤딩 방안
- 고정 파티션
  - 점수의 범위에 따라 파티션을 나누는 방안이다.
  - 점수가 고르게 분포되어야 한다.
  - 사용자의 점수가 높아져 다른 샤드로 옮겨야 할 때는 기존 샤드에서 해당 사용자를 제거한 후 다음 새 샤드로 옮겨야 한다.
 
- 해시 파티션
  - 레디스 클러스터를 사용하는 것으로, 사용자들의 점수가 특정 대역에 과도하게 모여 있는 경우 효과적이다.
  - 여러 노드에 데이터를 자동으로 샤딩하는 방법을 제공한다.
  - 각각의 키가 특정한 해시 슬롯에 속하도록 하는 샤딩 기법을 사용한다.

<br/>

### NoSQL을 대안으로 사용하는 방안
- 쓰기 연산에 최적화되어 있다.
- 같은 파티션 내의 항목을 점수에 따라 효율적으로 정렬 가능하다.
- ex. DynamoDB, 카산드라, MongoDB 등
- 레코드가 많아지면 상위 점수를 찾기 위해 전체 테이블을 뒤저야 하므로 사용자가 많아지면 성능이 떨어진다.
  - game_name#{year-month}을 파티션 키로, 점수를 정렬 키로 사용하면 해당 문제를 피할 수 있다.

<br/>

## 4️⃣ 마무리
- 정렬 집합을 사용하여 순위표를 구현하기로 했다.
- 레디스 캐시에 데이터를 샤딩하여 5억 DAU도 지원할 수 있도록 규모를 확장하는 방안을 살펴봤다.
- NoSQL 데이터베이스를 이용하는 방법도 살펴봤다.
- 더 빠른 조회 및 동점자 순위 판정 방안
  - 레디스 해시를 사용하면 문자열 필드와 값 사이의 대응관계를 저장해 둘 수 있다.
 
- 시스템 장애 복구
  - MySQL 데이터베이스에 타임스탬프와 함께 게임 승패를 기록한다는 사실을 활용하는 스크립트를 만들면 간단히 복구할 수 있다.
  - 레코드당 한 번씩 ZINCRBY를 호출한다.
