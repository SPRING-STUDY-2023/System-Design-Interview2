# 4장 분산 메시지 큐

> **메시지 큐를 사용할 때의 이점**

- 결합도 완화
- 규모 확장성 개선
- 가용성 개선
- 성능 개선

<br/>

> **유명한 분산 메시지 큐 시스템**

- 아파치 카프카
- 아파치 RocketMQ
- 아파치 RabbitMQ
- 아파치 펄사
- 아파치 ActiveMQ
- ZeroMQ

<br/>

### 메시지 큐 vs 이벤트 스트리밍 플랫폼
- 메시지 큐와 이벤트 스트리밍 플랫폼 사이의 차이는 지원하는 기능이 서로 수렴하면서 희미해지고 있다.
  - **메시지 큐** : RocketMQ, ActiveMQ, RabbitMQ, ZeroMQ 등
  - **스트리밍 플랫폼** : 카프카, 펄사
 
<br/>

## 1️⃣ 문제 이해 및 설계 범위 확정

### 기능 요구사항
- 생산자는 메시지 큐에 메시지를 보낼 수 있어야 한다.
- 소비자는 메시지 큐를 통해 메시지를 수신할 수 있어야 한다.
- 메시지는 반복적으로 수신할 수도 있어야 하고, 단 한 번만 수신하도록 설정될 수도 있어야 한다.
- 오래된 이력 데이터는 삭제될 수 있다.
- 메시지 크기는 KB 수준이다.
- 메시지가 생산된 순서대로 소비자에게 전달할 수 있어야 한다.
- 메시지 전달 방식은 최소 한 번, 최대 한 번, 정확히 한 번 가운데 설정할 수 있어야 한다.

<br/>

### 비기능 요구사항
- 높은 대역폭과 낮은 전송 지연 가운데 하나를 설정으로 선택 가능하게 하는 기능
- 규모 확장성 : 메시지 양이 급증해도 처리 가능해야 한다. (분산 시스템)
- 지속성 및 내구성 : 데이터는 디스크에 지속적으로 보관되어야 하며, 여러 노드에 복제되어야 한다.

<br/>

### 전통적 메시지 큐와 다른 점
- 전통적 메시지 큐
  - 메시지 보관 문제를 중요하게 다루지 않는다.
  - 메시지가 소비자에게 전달되기 충분한 기간 동안만 메모리에 보관한다.
  - 메시지 전달 순서를 보존하지 않는다.
 
<br/>

## 2️⃣ 개략적 설계안 제시 및 동의 구하기

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/77b16550-d69e-45fa-8345-160b9edfb8d3" />

🔼 메시지 큐의 핵심 컴포넌트
- 생산자는 메시지를 메시지 큐에 발행
- 소비자는 큐를 구독하고 구독한 메시지를 소비
- 메시지 큐는 생산자와 소비자 사이의 결합을 느슨하게 하는 서비스로, 생산자와 소비자의 독립적인 운영 및 규모 확장을 가능하게 하는 역할 담당
- 생산자와 소비자는 모두 클라이언트/서버 모델 관점에서 보면 클라이언트고 서버 역할을 하는 것은 메시지 큐이며 이 클라이언트와 서버는 네트워크를 통해 통신

<br/>

### 메시지 모델

- **일대일 모델**

  <img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/07a21cce-4e29-47c2-a836-6c6cc75a52e5"/>

  🔼 일대일 모델

  - 전통적인 메시지 큐에서 흔히 발견되는 모델이다.
  - 큐에 전송된 메시지는 오직 한 소비자만 가져갈 수 있다.
    - 어떤 소비자가 메시지를 가져갔다는 사실을 큐에 알리면 해당 메시지는 큐에서 삭제된다.
   
  - 데이터 보관을 지원하지 않는다.
    - 본 설계안은 메시지를 2주 동안은 보관할 수 있도록 하는 지속성 계층을 포함하며, 해당 계층을 통해 메시지가 반복적으로 소비될 수 있도록 한다.

<br/>

- **발행-구독 모델**

  <img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/cb410223-6d84-4fb1-b25d-1950a1b92458"/>
  
  🔼 발행-구독 모델

  - 메시지를 보내고 받을 때는 토픽에 보내고 받게 된다.
  - 토픽에 전달된 모든 메시지는 해당 토픽을 구독하는 모든 소비자에게 전달된다.
 
<br/>

### 토픽, 파티션, 브로커
메시지는 토픽에 보관된다.

<br/>

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/0bb36a51-d9dd-4fdf-9eb7-88797b20b005"/>

🔼 파티션
- 토픽에 보관되는 데이터의 양이 커져서 서버 한 대로 감당하기 힘들어지면, 파티션(partion), 즉 샤딩(sharding) 기법을 활용할 수 있다.
- 토픽을 여러 파티션으로 분할하여 메시지를 모든 파티션에 균등하게 나눠 보낸다.
- 파티션은 메시지 큐 클러스터 내의 서버에 고르게 분산 배치한다.
- 파티션을 유지하는 서버는 보통 브로커(broker)라 부른다.
- 파티션을 브로커에 분산함으로써 높은 규모 확장성을 달성할 수 있다.
- 각 토픽 파티션은 FIFO 큐처럼 동작한다.
- 파티션 내에서의 메시지 위치는 오프셋(offset)이라고 한다.
- 메시지에 키를 붙일 수 있는데, 같은 키를 가진 모든 메시지는 같은 파티션으로 보내지고, 키가 없는 메시지는 무작위로 선택된 파티션으로 전송된다.

<br/>

### 소비자 그룹

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/211d83e1-e1b7-47c4-ac5f-117bfa9e6b25" />

🔼 소비자 그룹
- 소비자 그룹 내 소비자는 토픽에서 메시지를 소비하기 위해 서로 협력한다.
- 하나의 소비자 그룹은 여러 토픽을 구독할 수 있고, 오프셋을 별도로 관리한다.
- 같은 그룹 내의 소비자는 메시지를 병렬로 소비할 수 있다.
- 데이터를 병렬로 읽으면 대역폭 측면에서는 좋지만 같은 파티션 안에 있는 메시지를 순서대로 소비할 수는 없다.
  - 어떤 파티션의 메시지는 한 그룹 안에서는 오직 한 소비자만 읽을 수 있도록 하면 해결할 수 있다.
  - 위 제약사항을 도입한 후 모든 소비자를 같은 소비자 그룹에 두면 같은 파티션의 메시지는 오직 한 소비자만 가져갈 수 있으므로 결국 일대일 모델에 수렴하게 된다.
 
<br/>

### 개략적 설계안

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/4ae64f78-2754-4d1f-b0c5-5ab6f0f02bc5"/>

🔼 개략적 설계안
- 클라이언트
  - `생산자`: 메시지를 특정 토픽으로 보낸다.
  - `소비자 그룹`: 토픽을 구독하고 메시지를 소비한다.
 
- 핵심 서비스 및 저장소
  - `브로커`: 파티션을 유지한다. 하나의 파티션은 특정 토픽에 대한 메시지의 부분 집합을 유지한다.
 
- 저장소
  - `데이터 저장소`: 메시지는 파티션 내 데이터 저장소에 보관된다.
  - `상태 저장소`: 소비자 상태는 이 저장소에 유지된다.
  - `메타데이터 저장소`: 토픽 설정, 토픽 속성 등은 이 저장소에 유지된다.
 
- 조정 서비스
  - `서비스 탐색`: 어떤 브로커가 살아있는지 알려준다.
  - `리더 선출`: 브로커 가운데 하나는 컨트롤러 역할을 담당해야 하며, 한 클러스터에는 반드시 활성 상태 컨트롤러가 하나 있어야 한다. 이 컨트롤러가 파티션 배치를 책임진다.
  - 아파치 주키퍼나 etcd가 보통 컨트롤러 선출을 담당하는 컴포넌트로 널리 이용된다.
 
<br/>

## 3️⃣ 상세 설계
- 디스크 기반 자료 구조를 활용한다.
- 생산자부터 소비자까지 전달되는 과정에서 데이터가 수정되지 않도록 하는 메시지 자료 구조를 설계하고 활용한다.
- 일괄 처리를 우선하는 시스템을 설계한다.

<br/>

### 데이터 저장소
- 읽기/쓰기가 빈번하게 일어난다.
- 갱신/삭제 연산은 발생하지 않는다.
- 순차적인 읽기/쓰기가 대부분이다.

<br/>

> **선택지1: 데이터베이스**

- `관계형 데이터베이스`: 토픽별로 테이블을 만든다.
- `NoSQL 데이터베이스`: 토픽별로 컬렉션을 만든다.
- 데이터베이스로는 본 설계안이 필요로 하는 데이터 사용 패턴을 지원하기 어렵다.

<br/>

> **선택지2: 쓰기 우선 로그**

- `WAL(Write-Ahead Log)`은 새로운 항목이 추가되기만 하는 일반 파일이다.
- WAL에 대한 접근 패턴은 읽기/쓰기 전부 순차적이다.

<br/>

#### 디스크 성능 관련 유의사항
- 데이터 장기 보관에 대한 요구사항 때문에 디스크 드라이브를 활용하여 다량의 데이터를 보관한다.
- 순차적 데이터 접근 패턴을 적극 활용하는 디스크 기반 자료 구조를 사용하면, 수백 MB/sec 수준의 읽기/쓰기 성능을 달성할 수 있다.
- WAL도 OS가 제공하는 디스크 캐시 기능을 적극적으로 활용한다.

<br/>

### 메시지 자료 구조
- 메시지 자료 구조는 생산자, 메시지 큐, 그리고 소비자 사이의 계약이다.

<br/>

#### 메시지 키
- 메시지의 키는 파티션을 정할 때 사용된다.
- 키가 주어지지 않은 메시지의 파티션은 무작위로 결정된다.

<br/>

#### 메시지 값
- 메시지 값은 메시지의 내용(페이로드)이다.
- 메시지 값은 일반 텍스트일수도, 압축된 이진 블록일수도 있다.

<br/>

#### 메시지의 기타 필드
- `토픽`: 메시지가 속한 토픽의 이름
- `파티션`: 메시지가 속한 파티션의 ID
- `오프셋`: 파티션 내 메시지의 위치, 메시지는 토픽, 파티션, 오프셋 3가지 정보를 알면 찾을 수 있다.
- `타임스탬프`: 메시지가 저장된 시각이다.
- `크기`: 메시지의 크기이다.
- `CRC`: 순환 중복 검사의 약자로, 주어진 데이터의 무결성을 보장하는 데 이용된다.

<br/>

### 일괄 처리
- 일괄 처리는 본 설계안에서 광범위하게 사용된다.
- 생산자, 소비자, 메시지 큐는 메시지를 가급적 일괄 처리한다.
- 일괄 처리가 성능 개선에 중요한 이유는 다음과 같다.
  - 여러 메시지를 한 번의 네트워크 요청으로 전송할 수 있도록 하기 때문에 네트워크 왕복 비용을 줄일 수 있다.
  - 더 높은 디스크 접근 대역폭을 달성할 수 있다.
 
<br/>

### 생산자 측 작업 흐름

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/d78c8329-15da-4347-b0ad-596c52183bfe"/>

🔼 라우팅 계층
1. 우선 생산자는 메시지를 라우팅 계층으로 보낸다.
2. 라우팅 계층은 메타데이터 저장소에서 사본 분산 계획을 읽어 자기 캐시에 보관한다.
   - 메시지가 도착 후 파티션-1의 리더 사본에 보낸다.
   - 예제에서 해당 사본은 브로커-1에 저장되어 있음을 알 수 있다.
  
3. 리더 사본이 메시지를 받고 해당 리더를 따르는 다른 사본은 해당 리더로부터 데이터를 받는다.
4. 충분한 수의 사본이 동기화되면 리더는 데이터를 디스크에 기록한다.

<br/>

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/8cea6bb2-f098-4ca1-b0fd-d079fbce79b4"/>

🔼 생산자 측 버퍼 및 라우팅 (수정본)
- 네트워크를 거칠 필요가 줄어들어 전송 지연이 줄어든다.
- 생산자는 메시지를 어느 파티션에 보낼지 결정하는 자신만의 로직을 가질 수 있다.
- 전송할 메시지를 버퍼 메모리에 보관했다가 목적지로 일괄 전송하여 대역폭을 높일 수 있다.

<br/>

### 소비자 측 작업 흐름
소비자는 특정 파티션의 오프셋을 주고 해당 위치에서부터 이벤트를 묶어 가져온다.

<br/>

### 푸시 vs 풀
🤔 브로커가 데이터를 소비자에게 보낼 것인가, 소비자가 브로커에서 가져갈 것인가?

<br/>

#### 푸시 모델
- 👍 낮은 지연: 브로커는 메시지를 받는 즉시 소비자에게 보낼 수 있다.
- 👎 소비자가 메시지를 처리하는 속도가 생산자가 메시지를 만드는 속도보다 느리면, 소비자에게 큰 부하가 걸릴 수 있다.
- 👎 생산자가 데이터 전송 속도를 좌우하므로, 소비자는 항상 그에 맞는 처리가 가능한 컴퓨팅 자원을 준비해두어야 한다.

<br/>

#### 풀 모델
- 👍 메시지를 소비하는 속도는 소비자가 알아서 결정한다.
- 👍 메시지 소비 속도가 생산 속도보다 느리면 소비자를 늘리거나 생산 속도를 따라잡을 때까지 기다려도 된다.
- 👍 일괄 처리에 적합하다.
- 👎 브로커에 메시지가 없어도 데이터를 끌어가려하면 컴퓨팅 자원 낭비로 이어진다.
  - 롱 폴링 지원: 당장 가져가 메시지가 없어도 일정 시간 기다리게 한다.
 
<br/>

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/9216035a-a377-4b93-b9d1-9932b8983d08"/>

🔼 풀 모델
1. 그룹-1에 합류하고 토픽-A를 구독하길 원하는 새로운 소비자가 있다. 그룹 이름을 해싱하여 접속할 브로커 노드를 찾는다.
2. 코디네이터는 해당 소비자를 그룹에 참여시키고 파티션-2를 해당 소비자에 할당한다.
3. 소비자는 마지막으로 소비한 오프셋 이후 메시지를 가져온다.
4. 소비자는 메시지를 처리하고 새로운 오프셋을 브로커에 보낸다.

<br/>

### 소비자 재조정
- 소비자 재조정은 어떤 소비자가 어떤 파티션을 책임지는지 다시 정하는 프로세스다.
  - 소비자 변경이 일어날 때 프로세스가 발생한다.

- 코디네이터는 소비자 재조정을 위해 소비자들과 통신하는 브로커 노드다.
  - 박동 신호가 사라지는 현상을 통해 소비자에게 발생한 장애를 감지할 수 있다.
  - 장애 감지 후 코디네이터는 재조정 프로세스를 시작하여 파티션을 재배치한다.
 
<br/>

### 상태 저장소
- 다음과 같은 정보가 저장된다.
  - 소비자에 대한 파티션의 배치 관계
  - 각 소비자 그룹이 각 파티션에서 마지막으로 가져간 메시지의 오프셋
 
- 소비자 상태 정보 데이터가 이용되는 패턴은 다음과 같다.
  - 읽기/쓰기가 빈번하게 발생하지만 양은 많지 않다.
  - 데이터 갱신은 빈번하게 일어나지만 삭제되는 일은 거의 없다.
  - 읽기/쓰기 연산은 무작위적 패턴을 보인다.
  - 데이터의 일관성이 중요하다.
 
<br/>

### 메타데이터 저장소
- 메타데이터 저장소에는 토픽 설정이나 속성 정보를 보관한다.
- 메타데이터는 자주 변경되지 않으며 양도 적다.
- 높은 일관성을 요구한다.
- 주키퍼가 적절하다.

<br/>

### 주키퍼
- 계층적 키-값 저장소 기능을 제공하는, 분산 시스템에 필수적인 서비스이다.
- 보통 분산 설정 서비스, 동기화 서비스, 이름 레지스트리 등으로 이용된다.
- 브로커 클러스터의 리더 선출 과정을 돕는다.

<br/>

### 복제
- 높은 가용성을 보장하기 위해 많이 사용되는 방법이다.
- 다른 사본은 리더에게서 새 메시지를 지속적으로 가져와 동기화한다.

<br/>

### 사본 동기화
- ISR은 성능과 영속성 사이의 타협점이다.
- 리더는 항상 ISR 상태다.
- 어느 사본 하나라도 동기화를 신속하게 처리하지 못하게 되면 파티션 전부가 느려지거나 아예 못 쓰게 되는 일이 벌어지고 말 것이다.

<br/>

#### ACK=all
생산자는 모든 ISR이 메시지를 수신한 뒤에 ACK 응답을 받는다.

<br/>

#### ACK=1
리더가 메시지를 저장하고 나면 바로 ACK 응답을 받는다.

<br/>

#### ACK=0
보낸 메시지에 대한 수신 확인 메시지를 기다리지 않고 계속 메시지를 전송하며 어떤 재시도도 하지 않는다.

<br/>

### 규모 확장성
