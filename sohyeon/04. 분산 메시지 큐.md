# 4장 분산 메시지 큐

> **메시지 큐를 사용할 때의 이점**

- 결합도 완화
- 규모 확장성 개선
- 가용성 개선
- 성능 개선

<br/>

> **유명한 분산 메시지 큐 시스템**

- 아파치 카프카
- 아파치 RocketMQ
- 아파치 RabbitMQ
- 아파치 펄사
- 아파치 ActiveMQ
- ZeroMQ

<br/>

### 메시지 큐 vs 이벤트 스트리밍 플랫폼
- 메시지 큐와 이벤트 스트리밍 플랫폼 사이의 차이는 지원하는 기능이 서로 수렴하면서 희미해지고 있다.
  - **메시지 큐** : RocketMQ, ActiveMQ, RabbitMQ, ZeroMQ 등
  - **스트리밍 플랫폼** : 카프카, 펄사
 
<br/>

## 1️⃣ 문제 이해 및 설계 범위 확정

### 기능 요구사항
- 생산자는 메시지 큐에 메시지를 보낼 수 있어야 한다.
- 소비자는 메시지 큐를 통해 메시지를 수신할 수 있어야 한다.
- 메시지는 반복적으로 수신할 수도 있어야 하고, 단 한 번만 수신하도록 설정될 수도 있어야 한다.
- 오래된 이력 데이터는 삭제될 수 있다.
- 메시지 크기는 KB 수준이다.
- 메시지가 생산된 순서대로 소비자에게 전달할 수 있어야 한다.
- 메시지 전달 방식은 최소 한 번, 최대 한 번, 정확히 한 번 가운데 설정할 수 있어야 한다.

<br/>

### 비기능 요구사항
- 높은 대역폭과 낮은 전송 지연 가운데 하나를 설정으로 선택 가능하게 하는 기능
- 규모 확장성 : 메시지 양이 급증해도 처리 가능해야 한다. (분산 시스템)
- 지속성 및 내구성 : 데이터는 디스크에 지속적으로 보관되어야 하며, 여러 노드에 복제되어야 한다.

<br/>

### 전통적 메시지 큐와 다른 점
- 전통적 메시지 큐
  - 메시지 보관 문제를 중요하게 다루지 않는다.
  - 메시지가 소비자에게 전달되기 충분한 기간 동안만 메모리에 보관한다.
  - 메시지 전달 순서를 보존하지 않는다.
 
<br/>

## 2️⃣ 개략적 설계안 제시 및 동의 구하기

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/77b16550-d69e-45fa-8345-160b9edfb8d3" />

🔼 메시지 큐의 핵심 컴포넌트
- 생산자는 메시지를 메시지 큐에 발행
- 소비자는 큐를 구독하고 구독한 메시지를 소비
- 메시지 큐는 생산자와 소비자 사이의 결합을 느슨하게 하는 서비스로, 생산자와 소비자의 독립적인 운영 및 규모 확장을 가능하게 하는 역할 담당
- 생산자와 소비자는 모두 클라이언트/서버 모델 관점에서 보면 클라이언트고 서버 역할을 하는 것은 메시지 큐이며 이 클라이언트와 서버는 네트워크를 통해 통신

<br/>

### 메시지 모델

- **일대일 모델**

  <img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/07a21cce-4e29-47c2-a836-6c6cc75a52e5"/>

  🔼 일대일 모델

  - 전통적인 메시지 큐에서 흔히 발견되는 모델이다.
  - 큐에 전송된 메시지는 오직 한 소비자만 가져갈 수 있다.
    - 어떤 소비자가 메시지를 가져갔다는 사실을 큐에 알리면 해당 메시지는 큐에서 삭제된다.
   
  - 데이터 보관을 지원하지 않는다.
    - 본 설계안은 메시지를 2주 동안은 보관할 수 있도록 하는 지속성 계층을 포함하며, 해당 계층을 통해 메시지가 반복적으로 소비될 수 있도록 한다.

<br/>

- **발행-구독 모델**

  <img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/cb410223-6d84-4fb1-b25d-1950a1b92458"/>
  
  🔼 발행-구독 모델

  - 메시지를 보내고 받을 때는 토픽에 보내고 받게 된다.
  - 토픽에 전달된 모든 메시지는 해당 토픽을 구독하는 모든 소비자에게 전달된다.
 
<br/>

### 토픽, 파티션, 브로커
메시지는 토픽에 보관된다.

<br/>

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/0bb36a51-d9dd-4fdf-9eb7-88797b20b005"/>

🔼 파티션
- 토픽에 보관되는 데이터의 양이 커져서 서버 한 대로 감당하기 힘들어지면, 파티션(partion), 즉 샤딩(sharding) 기법을 활용할 수 있다.
- 토픽을 여러 파티션으로 분할하여 메시지를 모든 파티션에 균등하게 나눠 보낸다.
- 파티션은 메시지 큐 클러스터 내의 서버에 고르게 분산 배치한다.
- 파티션을 유지하는 서버는 보통 브로커(broker)라 부른다.
- 파티션을 브로커에 분산함으로써 높은 규모 확장성을 달성할 수 있다.
- 각 토픽 파티션은 FIFO 큐처럼 동작한다.
- 파티션 내에서의 메시지 위치는 오프셋(offset)이라고 한다.
- 메시지에 키를 붙일 수 있는데, 같은 키를 가진 모든 메시지는 같은 파티션으로 보내지고, 키가 없는 메시지는 무작위로 선택된 파티션으로 전송된다.

<br/>

### 소비자 그룹

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/211d83e1-e1b7-47c4-ac5f-117bfa9e6b25" />

🔼 소비자 그룹
- 소비자 그룹 내 소비자는 토픽에서 메시지를 소비하기 위해 서로 협력한다.
- 하나의 소비자 그룹은 여러 토픽을 구독할 수 있고, 오프셋을 별도로 관리한다.
- 같은 그룹 내의 소비자는 메시지를 병렬로 소비할 수 있다.
- 데이터를 병렬로 읽으면 대역폭 측면에서는 좋지만 같은 파티션 안에 있는 메시지를 순서대로 소비할 수는 없다.
  - 어떤 파티션의 메시지는 한 그룹 안에서는 오직 한 소비자만 읽을 수 있도록 하면 해결할 수 있다.
  - 위 제약사항을 도입한 후 모든 소비자를 같은 소비자 그룹에 두면 같은 파티션의 메시지는 오직 한 소비자만 가져갈 수 있으므로 결국 일대일 모델에 수렴하게 된다.
 
<br/>

### 개략적 설계안

<img alt="image" width="500" src="https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/55437339/4ae64f78-2754-4d1f-b0c5-5ab6f0f02bc5"/>

🔼 개략적 설계안
- 클라이언트
  - `생산자`: 메시지를 특정 토픽으로 보낸다.
  - `소비자 그룹`: 토픽을 구독하고 메시지를 소비한다.
 
- 핵심 서비스 및 저장소
  - `브로커`: 파티션을 유지한다. 하나의 파티션은 특정 토픽에 대한 메시지의 부분 집합을 유지한다.
 
- 저장소
  - `데이터 저장소`: 메시지는 파티션 내 데이터 저장소에 보관된다.
  - `상태 저장소`: 소비자 상태는 이 저장소에 유지된다.
  - `메타데이터 저장소`: 토픽 설정, 토픽 속성 등은 이 저장소에 유지된다.
 
- 조정 서비스
  - `서비스 탐색`: 어떤 브로커가 살아있는지 알려준다.
  - `리더 선출`: 브로커 가운데 하나는 컨트롤러 역할을 담당해야 하며, 한 클러스터에는 반드시 활성 상태 컨트롤러가 하나 있어야 한다. 이 컨트롤러가 파티션 배치를 책임진다.
  - 아파치 주키퍼나 etcd가 보통 컨트롤러 선출을 담당하는 컴포넌트로 널리 이용된다.
 
<br/>

## 3️⃣ 상세 설계
다음 주차
