# 3장. 구글 맵
## About 구글 맵

> 위성 이미지, 거리 뷰, 실시간 교통 상황, 경로 계획 등 다양한 서비스를 제공
> 

⇒ 사용자가 목적지와 경로를 찾을 수 있도록 돕는다

- DAU 10억 명
- 전 세계 99% 지역의 지도 제공
- 매일 2500만 건의 업데이트 반영 → 정확한 실시간 위치 정보를 제공하기 위함

## 1단계 문제 이해 및 설계 범위 확정

**[요구사항 파악하기]**

- DAU : 10억 명으로 가정
- Focusing 해야 할 주요 기능
    
    **위치 갱신**, 방향 안내, **경로 안내**, **예상 도착 시간(ETA)**, **지도 표시** 등
    
- 데이터 규모
    - 도로 데이터 : 수 TB 수준의 가공되지 않은 데이터 (다양한 경로를 확보했다고 가정)
- 고려사항
    - 교통 상황 : 도착 시간을 정확하게 추정하는 데 매우 중요 ⭐
    - 이동 수단 : 운전, 대중교통, 도보 등 다양한 이동 방법을 지원해야 함
    
    *고려하지 않는 것
    
    - 경로 안내 시 경유지 설정 → 고려X
    - 사업장 위치 및 사진 표시, 최대 허용되는 사진 수  → 고려X

### 기능 요구사항

[주요 기능]

1. 사용자 위치 갱신
2. 경로 안내 서비스 (ETA 서비스 포함)
3. 지도 표시

[지원할 주 단말]

모바일 전화기 (스마트폰)  *데이터 사용량과 배터리 효율을 중시

### 비기능 요구사항 및 제약사항

- `정확도` : 사용자에게 잘못된 경로를 안내해서는 안 됨
- `부드러운 경로 표시` : 클라이언트를 통해 제공되는 경로 안내 용도의 지도는 아주 부드럽게 표시되고 갱신되어야 함
- `데이터 및 배터리 사용량` : 클라이언트는 가능한 한 최소한의 데이터와 배터리를 사용해야 함   *모바일 단말에 중요한 요구사항
- `가용성`
- `규모 확장성`

### 지도 101

- 측위 시스템
    
    > 구 표면 상의 위치를 표현하는 체계
    > 
    - 위도(latitude) : 주어진 위치가 얼마나 북쪽/남쪽인지
    - 경도(longitude) : 얼마나 동쪽/서쪽인지

- 3차원 위치의 2차원 변환
    
    > [지도 투영법](https://ko.wikipedia.org/wiki/%EC%A7%80%EB%8F%84_%ED%88%AC%EC%98%81%EB%B2%95)(map projection) / 도법 : 3차원 구 위의 위치를 2차원 평면에 대응시키는 절차
    > 
    
    *거의 모든 투영법은 실제 지형의 기하학적 특성을 왜곡한다
    
    <aside>
    📌 구글 맵은 메르카토르 도법을 조금 변경한 웹 메르카토르(Web Mercator) 도법을 사용중!
    
    </aside>
    
- 지오코딩(Geocoding)
    
    > 주소를 지리적 측위 시스템의 좌표로 변환하는 프로세스
    > 
    - 미국 내 주소 ‘1600 Amphitheatre Parkway, Mountain View, CA’ <=> (위도 37.423021, 경도 -122.083739)
    - `역 지오코딩` : 지오코딩 결과 → 반대로 주소로 변환하는 프로세스
    
    [방법]  인터폴레이션(interpolation)
    
    GIS(Geographic Information System)와 같은 다양한 시스템이 제공하는 데이터를 결합한다는 뜻
    

- 지오해싱(Geohashing)
    
    > 지도 위 특정 영역을 영문자와 숫자로 구성된 짧은 문자열에 대응시키는 인코딩 체계
    > 
    
    → 2차원의 평면 공간으로 표현된 지리적 영역 위의 격자를 더 작은 격자로 재귀적으로 분할해 나감
    
    - 각 격자는 정사각형 / 사각형
    - 어떤 격자를 재귀적으로 분할한 결과로 더 작은 격자가 생성되고, 이는 0~3의 번호가 부여됨
    
    [용도]  맵 타일 관리
    
- 지도 표시
    
    > `타일(tile)` : 지도 전부를 하나의 이미지로 표시하는 대신, 작은 타일로 쪼개어 표시하는 것
    > 
    - 타일은 지도를 화면에 표시하는 데 가장 기본적인 개념
    - 클라이언트는 사용자가 보려는 영역에 관계된 타일만 다운받아 모자이크처럼 이어 붙인 다음 화면에 뿌림
    - **지도 확대/축소 기능**과 연관 - 지도 확대 수준(zoom level)에 따라 어떤 크기의 타일을 가져올지 고르는 방식
        
        → 사용자가 전체 지도를 한눈에 다 보는 경우, 수십만 타일을 전부 다운로드할 필요는 없음 (전체를 256X256 픽셀 이미지 하나로 표현하는 지도 한 장으로 충분!)
        
    
- 경로 안내 알고리즘을 위한 도로 데이터 처리
    
    > Dijkstra 알고리즘, A* 경로 탐색 알고리즘 활용 → 그래프 자료구조 [교차로 = Node, 도로 = Edge]
    > 
    - 대부분의 경로 탐색 알고리즘은 **그래프 크기**에 아주 민감
        - 전 세계 도로망을 하나의 그래프로 표현하기에는, 메모리 차지와 경로 탐색 성능 측면에서 만족스럽지 않을 것임!
        - 설계안에서 가정하는 규모에도 좋은 성능을 보이려면 그래프를 **관리 가능 단위**로 분할할 필요가 있음
            
            
    
    <aside>
    🌐 `타일 기반 분할법`과 유사 : 세계를 작은 격자로 나누고, 각 격자 안의 도로망을 노드(교차로)와 선(도로)으로 구성된 그래프 자료 구조로 변환
    
    - 각 격자는 경로 안내 타일(routing tile)이라 부름
    - 각 타일은 도로로 연결된 다른 타일에 대한 참조를 유지
    
    ⇒ 연결된 타일들을 지나갈 때 보일 더 큰 도로망 그래프를 만들어낼 수 있고, 
    도로망을 언제든 불러올 수 있는 경로 안내 타일로 분할해 놓음으로써 **메모리 요구량**을 낮추고, 한번에 처리해야 하는 경로의 양이 줄어들어 **경로 탐색 성능**도 좋아진다
    
    </aside>
    
- 계층적 경로 안내 타일
    
    > 경로 안내가 효과적으로 동작하기 위해, 필요한 수준의 구체성을 갖춘 도로 데이터가 필요하다
    > 
    
    이 구체성 정도를 상/중/하로 구분하여, 3가지 종류의 경로 안내 타일을 준비한다
    
    - `상` : 가장 구체성이 높은 타일로, 크기가 매우 작음 → 지방도(local roads) 데이터
    - `중` : 더 넓은 지역을 커버하며, 규모가 비교적 큼 → 관할구(district)를 잇는 간선 도로 데이터
    - `하` : 구체성이 가장 낮은 타일로, 큰 영역을 커버함 → 도시와 주를 연결하는 주요 고속도로 데이터
    

### 개략적 규모 추정

<aside>
📏 [참고] 도량형 변환 규칙

- 1피트 = 0.3048미터
- 1킬로미터 = 0.6241마일 = 1000미터
</aside>

- 저장소 사용량
    
    
    | 세계 지도 | 지원하는 확대 수준별로 지도 타일을 한 벌씩 두고, 지도를 최대 확대했을 때의 전부 보관하는 데 필요한 타일 개수를 따져봐야 함 ex. 1장의 타일=256X256픽셀 압축 PNG 파일일 때, 1장당 100KB의 저장공간이 필요하므로, 최대 확대 시 총 4.4조X100KB=440PB 만큼의 저장공간이 필요할 것. |
    | --- | --- |
    | 메타데이터(metadata) | 각 지도 타일의 메타데이터는 크기가 아주 작아서 무시해도 지장 無 |
    | 도로 정보 | (가정)외부에서 받은 수 TB 용량의 도로 데이터 → 경로 안내 타일로 변환 (용량은 변환 전후 큰 차이가 없을 것) |
- 서버 대역폭
    
    [요청의 유형]
    
    1. **경로 안내 요청** : 클라이언트가 경로 안내 세션을 시작할 때 전송하는 메시지
        
        ex. 각 사용자가 경로 안내 기능을 평균적으로 주당 35분 사용한다고 가정할 때, (DAU는 10억 명으로 가정)
        
        주당 350억 분, 하루에 50억 분
        
        <aside>
        ❗ <b>QPS</b>
        
        1. GPS 좌표를 매초 전송하기
            
            하루에 3000억 건의 요청이 발생하고(50억 분 X 60) 이는 3백만 QPS에 해당 (3000억 건의 요청/10^3 = 3백만)
            
        2. 요청을 클라이언트 쪽에 모아 두었다가 덜 자주 보내도록 하기(15초 or 30초마다 한 번씩) ✅
            
            쓰기 QPS를 낮출 수 있음  *요청 빈도는 사용자의 이동 속도 등 다양한 요건에 의해 결정
            
            ex. 사용자가 꽉 막힌 도로에 있는 경우, GPS 위치 업데이트를 자주 보낼 필요가 없기 때문
            
        
        🟢 본 설계안의 경우, GPS 위치 변경 내역은 모아두었다가 15초마다 한 번씩 서버로  
        
        </aside>
        
    2. **위치 갱신 요청** : 클라이언트가 경로 안내를 진행하는 동안 변경된 사용자 위치를 전송하는 메시지
        
        → 구글 맵 서비스에서는 이 위치 정보를 **실시간 교통상황 데이터 계산 과정의 입력**과 같이 다양한 방식으로 이용
        
        *GPS 위치 변경 내역은 모아두었다가 15초마다 한 번씩 서버로 보낸다고 가정 
        
        > 위치 정보 갱신 요청 최대 QPS = 200,000 X 5 = 1백만
        > 
    

## 2단계 개략적 설계안 제시 및 동의 구하기

![IMG_7408.jpg](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/a8593c94-0847-4614-96a9-464c446eba20)

1. 위치 서비스(location service)
2. 경로 안내 서비스(navigation service)
3. 지도 표시(map rendering)

### 위치 서비스

> 사용자의 위치를 기록하는 역할
> 

[가정] 위치 변경 내역은 매초 측정하되, 클라이언트가 t초마다 자기 위치를 전송한다  (t는 설정 가능한 값)

<aside>
⭐ **주기적으로 위치 정보를 전송하는 방식의 장점**

1. 해당 데이터 스트림을 활용하여 시스템을 점차 개선할 수 있다
    - 실시간 교통 상황 모니터링
    - 새로 만들어진 도로나 폐쇄된 도로 탐지
    - 사용자 행동 양태 분석을 통해 개인화된 경험 제공
2. 클라이언트가 보내는 위치 정보(실시간 정보)의 ETA를 보다 정확하게 산출할 수 있고, 교통 상황에 따라 다른 경로를 안내할 수도 있다
</aside>

사용자의 위치가 바뀔 때마다 그 즉시 서버로 전송해야 하는 건 아니므로, 위치 이력을 클라이언트에 버퍼링해 두었다가 일괄 요청(batch request)하면 전송 빈도를 줄일 수 있다

![IMG_7418.jpg](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/a9b576c0-eeec-47c6-a98f-7d042d8fe150)

갱신 요청 빈도를 줄여도 여전히 높은 쓰기 요청 빈도를 가지는 구글 맵 시스템은 아래와 같은 설계를 고려해볼 수 있다.

- 카산드라(Cassandra) 데이터베이스 - 높은 빈도의 쓰기 요청에 최적화, 규모 확장 용이
- 카프카(Kafka) 스트림 처리 엔진 - 위치 데이터 로깅
- HTTP 통신 프로토콜
    - keep-alive 옵션
    - 형태
        
        ```json
        POST /v1/locations
        인자: 
        locs: JSON으로 인코딩한 (위도, 경도, 시각) 순서쌍 배열
        ```
        

### 경로 안내 서비스

> A에서 B 지점으로 가는 합리적으로 빠른 경로를 찾아주는 역할
> 

*결과를 얻는 데 드는 시간 지연은 어느 정도 감내할 수 있다

- ❗계산된 경로는 최단시간 경로일 필요는 없으나, 정확도는 보장되어야 한다

`GET`  /v1/nav?origin=1355+market+street,SF&description=Disneyland

출발지와 목적지를 인자로 전달한 API 요청을 보내면, 로드밸런서를 거쳐 서비스에 도달한다 

```json
{
	'distance': {'text': '0.2 mi', 'value': 259},
	'duration': {'text': '1 min', 'value': 83},
	'end_ location': {'lat': 37.4038943, 'Ing': -121.9410454},
	'html_instructions': 'Head <b>northeast</b> on <D>brandon St</bs
			toastreaumin waye/Bad sty le font-saze： .Serl Restitea
			usage roads/div»,
	'polyline': {'points': '_fhcFjbhgVuAwDsCal'},
	'start_ location': {'lat': 37.4027165, '1ng': -121.9435809},
	'geocoded_waypoints': [
	{
			"geocoder _status" : "OK",
			"partial_match" : true,
			"place_id" : "ChIJwZN™t¡1fawwRO2aVVVX2yKg",
			"types" : [ "locality", "political" ]
	},
	{
			"geocoder_status" : "OK",
			"partial_match" : true,
			"place_id" : "ChIJaPgQGtXawwRLYe¡B™U¡7b™",
			"types" : [ "locality", "political" ]
	}
	],
	'travel_ mode': 'DRIVING'
}
```

→ 경로 재탐색이나 교통 상황 변화 같은 문제는 적응형 ETA (adaptive ETA)를 통해 해결 가능

### 지도 표시

클라이언트가 모든 확대 수준별 지도 타일을 저장하는 건 비효율적이므로, **클라이언트의 위치 및 현재 클라이언트가 보는 확대 수준에 따라 필요한 타일을 서버에서 가져오는 접근법**이 바람직하다

> [Scenario] 언제 지도 타일을 서버에서 가져오는가?
> 

I. 사용자가 지도를 확대 또는 이동시키며 주변을 탐색한다

II. 경로 안내가 진행되는 동안 사용자의 위치가 현재 지도 타일을 벗어나 인접한 타일로 이동한다

> [Choice] 다량의 지도 타일 데이터를 서버에서 효과적으로 가져오려면?
> 

Case I. 클라이언트의 위치, 현재 클라이언트가 보는 지도의 확대 수준에 근거하여 필요한 지도 타일을 즉석에서 만드는 방안

→ ⚠️ BUT 사용자의 위치 및 확대 수준의 조합은 무한하다

- 모든 지도 타일을 동적으로 만들어야 하는 서버 클러스터에 심각한 부하가 걸린다
- 캐시를 활용하기가 어렵다

Case II. 확대 수준별로 미리 만들어 둔 지도 타일을 클라이언트에 전달하기만 하는 방법

→ 각 지도 타일이 담당하는 지리적 영역 : 지오해싱 같은 분할법을 사용해 만든 고정된 사각형 격자로 표현되므로 정적(static)

- 클라이언트는 지도 타일이 필요할 경우, 현재 확대 수준에 근거하여 필요한 지도 타일 집합을 결정한다
- 그 다음, 각 위치를 지오해시 URL로 변환한다

<aside>
📌 CDN을 통한 사전 생성된 지도 이미지 서비스

1. 모바일 단말 사용자는 지도 타일 요청을 CDN에 보냄
2. 해당 타일이 CDN을 통해 서비스된 적이 없는 경우, CDN은 원본 서버에서 해당 파일을 가져와 그 사본을 캐시에 보관한 다음 사용자에게 반환함
3. 그 뒤로 다른 사용자가 같은 파일을 요청하면 CDN은 캐시에 보관한 사본을 서비스하며, 원본 서버는 다시 접촉하지 않음

👍🏻 규모 확장에 용이하고 성능 측면에서도 유리함 (사용자에게 가장 가까운 POP(Point Of Presense)에서 파일을 서비스하기 때문)

![IMG_7419.jpg](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/80c5fffd-34de-498d-bdf2-67cb73e04c8d)

→ ***지도 타일은 정적이므로 캐시를 통해 서비스하기에 아주 적합!***

<aside>
✔️ 데이터 사용량

> 경로 안내를 진행하는 동안 클라이언트가 일반적으로 필요로 하는 데이터 양을 계산해보자 (단, 클라이언트 측 캐시는 고려하지 않는다)
> 
- 클라이언트에 캐시를 두면? 사람들은 일반적으로 같은 길을 이용하는 경향이 있으므로, 훨씬 데이터 사용량을 줄일 수 있을 것!

[가정] 사용자가 30km/h 속도로 이동 중, 한 이미지는 200mX200m 영역을 표현하도록 확대하여 지도를 표시하고 있는 상황

- 이미지 1장 : 256X256픽셀
- 평균 이미지 크기 : 100KB

1kmX1km 영역을 표현하려면 이미지 25장이 필요하다 → 이를 저장용량으로 환산하면 2.5MB(25X100KB)

ex. 30km/h 속도로 이동한다고 할 때, 시간당 75MB의 데이터가 소진되며(30X2.5MB), 이는 분당 1.25MB에 해당

</aside>

<aside>
✔️ CDN을 통해 서비스되는 트래픽 규모

매일 50억 분 가량의 경로 안내를 처리한다고 가정할 때, 이는 50억 X 1.25MB = 6.25PB/일에 해당하는 양이다

⇒ 초당 전송해야 하는 지도 데이터의 양 : 62,500MB (6.25PB/10^5초/하루)

CDN을 사용하면 지도 이미지는 전 세계에 흩어져 있는 POP를 통해 제공될 것이며, 전 세계에 200개의 POP가 있다고 가정할 때, 각 POP는 수백(62,500/200) MB 정도의 트래픽만 처리하면 된다 

</aside>

</aside>

> 클라이언트는 CDN에서 지도 타일을 가져올 URL을 어떻게 결정할까?
> 

지도 타일은 이미 정의된 격자에 맞게 확대 수준별로 한 벌씩 미리 만들어 둔 것을 사용한다

→ 지오해시를 사용해서 격자를 나누므로, 모든 격자는 고유한 지오해시 값을 가진다.

[계산방식] 위도/경도로 표현된 클라이언트 위치 및 현재 지도 확대 수준을 INPUT으로 → 화면에 표시할 지도 타일에 대응되는 지오해시 계산(클라이언트에서 수행) → 해당 지오해시 및 URL로 CDN에서 지도 타일을 가져옴

ex. https://cdn.map-provider.com/tiles/9q9hvu.png

### ETC

[주의사항]

⚠️ 지오해시 계산 알고리즘을 클라이언트가 수행해도 되지만, 지원해야 할 플랫폼이 많을 때 문제가 될 수 있으므로 주의하자

⚠️ 모바일 앱 업데이트 배포는 시간이 오래 걸리고 때로는 위험한 프로세스임 ⇒ **맵 타일 인코딩에 지오해싱을 사용한다는 보장이 있어야 한다**

[기타 고려사항]

주어진 위도/경도 및 확대 수준을 타일 URL로 변환하는 알고리즘은 별도 서비스에 두는 것을 고려해볼 수 있다

→ 사용자가 새로운 위치로 이동하거나 확대 수준을 변경하면, 위도, 경도, 현재 확대 수준을 입력으로 하여 타일 URL을 계산하는 역할을 담당하는 간단한 서비스

![IMG_7420.jpg](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/566c2440-9e0d-4743-8f52-faa340c950de)

1. 모바일 사용자가 타일 URL들을 가져오기 위해 지도 타일 서비스를 호출한다 (이 요청은 로드밸런서로 전달)
2. 로드밸런서는 해당 요청을 지도 타일 서비스로 전달한다
3. 지도 타일 서비스는 클라이언트의 위치와 확대 수준을 입력으로 삼아 9개의 타일 URL을 계산한 다음 클라이언트에 반환한다 (표시할 타일 하나의 8개의 주변 타일이 응답에 포함됨)
4. 모바일 클라이언트는 해당 타일을 CDN을 통해 다운로드한다


## 3단계 상세 설계

### 데이터 모델

<aside>
🔎 데이터 모델

1. 경로 안내 타일
2. 사용자 위치
3. 지오코딩 데이터
4. 미리 계산해 둔 지도 타일 데이터
</aside>

**1️⃣ 경로 안내 타일**

- `구성`  방대한 양의 도로 및 메타데이터(이름, 관할구, 위도, 경도 등의 도로 부속 정보)
    - 주어진 상태 그대로 경로 안내 알고리즘의 INPUT으로 활용하기는 어려운 형태
- `용량`  수 테라바이트
    - 애플리케이션이 지속적으로 수집한 사용자 위치 데이터를 통해 끊임없이 개선됨
    

> **경로 안내 타일 처리 서비스**(오프라인 데이터 가공 파이프라인)를 주기적으로 실행하여 경로 안내 타일을 변환한다.
> 
- 경로 안내 타일 = 그래프의 노드와 선분으로 표현된 해당 지역 내 교차로와 도로 정보
- 경로 안내 알고리즘 = 타일이 모인 결과로 만들어지는 도로망 데이터를 점진적으로 소비

> 경로 안내 타일 서비스에서 가공 결과로 만든 타일은 어디에 저장할까??
> 

그래프 데이터는 메모리에 인접 리스트 형태 or 데이터베이스 레코드로 보관하는 것이 일반적이지만, 본 설계안에서는 **양이 많은 타일 데이터를 다루므로 S3 같은 객체 저장소에 파일을 보관하고 그 파일을 이용할 경로 안내 서비스에서 적극적으로 캐싱하는 방안**을 도입한다. 

*인접 리스트 → 이진 파일로 직렬화하여 저장

- 객체 저장소에 지오해시 기준으로 분류해두면, 위도와 경도가 주어졌을 때 신속하게 타일을 찾을 수 있다

**2️⃣ 사용자 위치 데이터**

`용도`

1. 도로 데이터 및 경로 안내 타일 갱신
2. 실시간 교통 상황 데이터나 교통 상황 이력 데이터베이스 구축
3. 데이터 스트림 프로세싱 서비스에서 이 위치 데이터를 처리하여 지도 데이터 갱신

> 사용자의 위치 데이터를 저장하려면, 엄청난 양의 쓰기 연산을 잘 처리할 수 있으면서 수평적 규모 확장이 가능한 DB가 필요하다
> 

❗ Cassandra가 적합

| user_id | timestamp | user_mode | driving_mode | location |
| --- | --- | --- | --- | --- |
| 101 | 163273682 | active | driving | (20.0, 30.5) |

**3️⃣ 지오코딩 데이터베이스**

- `구성`  주소를 위도/경도 쌍으로 변환하는 정보 보관
    
    →  레디스처럼 빠른 읽기 연산을 제공하는 키-값 저장소가 적합 *(read >>> write)*
    
- `용도`  출발지, 목적지 주소는 경로 계획 서비스에 전달하기 전에 이 DB를 통해 위도/경도 쌍으로 변환되어야 함

**4️⃣ 미리 만들어 둔 지도 이미지**

단말이 특정 영역의 지도를 요청하면 인근 도로 정보를 취합하여 모든 도로 및 관련 상세 정보가 포함된 이미지를 만들어 내야 한다. 

→ 계산 자원을 많이 사용 & 같은 이미지의 중복 요청 多

> 이미지는 한 번만 계산하고 그 결과를 캐시해두는 전략
> 
- 이미지는 지도 표시에 사용하는 확대 숙준별로 미리 만들어두고, CDN을 통해 전송한다
- CDN 원본 서버로는 아마존 S3 같은 클라우드 저장소를 활용한다

### 서비스

**1️⃣ 위치 서비스**

<aside>
👥 사용자 위치 데이터 처리

- NoSQL 키-값 데이터베이스 or 열 중심(column-oriented) 데이터베이스 활용
    
    e.g 카산드라 (높은 가용성을 보장하면서 막대한 규모의 연산 감당 가능)
    
- 초당 백만 건의 위치 정보 업데이트 (write) 발생
- ~~일관성~~, **가용성, 분할 내성** → 2가지에만 focusing (by CAP 정리)
</aside>

`Key` (user_id, timestamp)

- user_id : 파티션 키 ⇒ 특정 사용자의 최근 위치를 신속히 읽어 내기 위함

- timestamp : 클러스터링 키 ⇒ 같은 파티션 키를 갖는 데이터는 함께 저장되며, 클러스터링 키 값에 따라 정렬됨

`Value` 위도/경도 쌍

| key(user_id) | timestamp | lat | long | user_mode | navigate_mode |
| --- | --- | --- | --- | --- | --- |
| 51 | 163273682 | 21.9 | 89.8 | active | driving |

> 사용자 위치 데이터는 어떻게 이용되는가
> 

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/80024278/d24f9bf0-902b-4578-9f2b-f76a9c45edf1)

1. 새로 개설되었거나 폐쇄된 도로 감지
2. 지도 데이터의 정확성 개선하는 입력
3. 실시간 교통 현황 파악하는 입력

→ 이를 지원하기 위해 사용자 위치를 데이터베이스에 기록하는 것과 별도로 카프카와 같은 메식지 큐에 로깅한다

<aside>
❗ 카프카(Kafka)

응답 지연이 낮고 많은 데이터를 동시에 처리할 수 있는 데이터 스트리밍 플랫폼

- 실시간 데이터 피드 지원
- 개별 서비스는 카프카를 통해 전달되는 사용자 위치 데이터 스트림을 각자 용도에 맞게 활용함 (e.g. 실시간 교통 상황 서비스)
</aside>

> 지도 표시
> 
- **지도 타일 사전 계산 [지도 타일을 미리 만들어 놓는 방법]**
    
    *구글 맵은 21단계로 지도를 확대할 수 있으며, 확대 수준 0은 세계 전부를 **256X256 픽셀**짜리 타일 하나로 표현한다
    
    → 확대 수준을 1단계 올릴 때마다 해당 수준을 위한 전체 타일 수는 동서 방향으로 2배, 남북 방향으로 2배 늘어난다
    
    - 확대 수준 1에 필요한 타일 = 2X2장 = 512X512 픽셀
    - 확대 수준 2에 필요한 타일 = 4X4장 = 1024X1024 픽셀
    
    ❗ 확대 수준을 1단계 늘릴 때마다 해당 수준 전부를 합친 해상도는 그 이전 수준 대비 4배씩 늘어난다 (사용자에게 더 상세한 정보를 제공할 수 있다)
    
    - 클라이언트는 위 정보를 제공하기 위한 타일을 다운받는 데 많은 네트워크 대역폭을 소진하지 않고도 클라이언트에 설정된 확대 수준에 최적인 크기의 지도를 표시할 수 있다
    
    ![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/80024278/43afb329-d959-4da8-9c1e-3866046be926)
    
- **최적화: 벡터 사용 [지도 표시 최적화 기법]**
    
    지도 표시에 WebGL 기술을 채택하면, 네트워크를 통해 이미지를 전송하는 대신 경로와 다각형 등의 벡터 정보를 보내게 된다. → 클라이언트는 수신된 경로와 다각형 정보를 통해 지도를 그려내면 된다
    
    👍🏻 벡터 타일의 장점 - 이미지에 비해 월등한 압축률울 가지므로, 네트워크 대역폭을 많이 아낄 수 있다
    

 **2️⃣경로 안내 서비스**

> 가장 빠른 경로를 안내하는 역할
> 

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/80024278/9f9c959a-9b38-4f08-9ab1-28d1df0a4d18)

**`지오코딩 서비스`** :  주소 → (위도, 경도) 쌍으로 바꿔주는 서비스 

*주소의 표현 방식이 다양할 수 있다는 점 고려

**[구글 지오코딩 API의 요청/응답 사례]**

- Request
    
    https:/maps.googleapis.com/maps/api/geocode/json?address=1600+Amphit Mountain+View, +CA
    
- Response (JSON)
    
    ```jsx
    {
    	"results" : [
    			"formatted_address" : "1600 Amphitheatre Parkway, Mountain Veiw, AC 94043, USA",
    			"geometry": {
    					"location" : {
    					"lat" : 37.4224764,
    					"Ing" : -122.0842499
    			},
    			"locoaitn_type" : "ROOFTOP", 
    			"viewport" : {
    					"northeast" : {
    							"lat" : 37.4238253802915,
    							"lng" : -122.0829009197085
    					},
    					"southwest" : {
    							"lat" : 37.4211274197085, 
    							"lng": -122.0855988802915
    					},
    			},
    			"place_id" : "ChIJ2eUgeAK6j4ARbn5u_wAGqWA" , 
    			"plus_code": {
    					"compound_code": "CWC8+W5 Mountain View, California United States",
    					"global_code": "2891DAJAS",
    			},
    			"types": [ "street_address" ]
    			}
    		}
    	],
    	"status": "OK"
    }
    ```
    

**`경로 계획 서비스`(route planner service)** :  현재 교통 상황과 도로 상태에 입각하여 이동 시간 측면에서 최적화된 경로를 제안하는 여할

→ 다른 서비스들과의 통신으로 결과를 만들어 냄

**`최단 경로 서비스` (shortest path service)** :  출발지와 목적지 위도/경도를 입력으로 받아 k개의 최단 경로를 반환하는 서비스

*교통, 도로 상황은 고려하지 않음 ⇒ 도로 구조에만 의존하여 계산 수행

*도로망 그래프는 거의 정적이므로 캐시해두면 좋음

[A* 경로 알고리즘의 Flow ← 객체 저장소에 저장된 경로 안내 타일]

1. 입력으로 출발지와 목적지의 위도/경도를 받음 
2. 이 위치 정보를 지오해시로 변환 후, 출발지와 목적지 경로 안내 타일을 얻음
3. 출발지 타일에서 시작하여 그래프 자료 구조를 탐색해 나감 (탐색 범위를 넓히는 과정에서 필요한 주변 타일은 객체 저장소/캐시에서 가져옴)
    
    ⚠️ 같은 지역의 다른 확대 수준 타일로도 연결이 존재할 수 있음!
    
    → 고속도로만 있는 더 큰 타일로 진입하거나 할 수 있는 것은 알고리즘이 그런 연결을 택할 수 있기 때문
    

> 이는 경로가 충분히 확보될 때까지 검색범위를 계속 확대해 나가면서 필요한 만큼 타일을 가져오는 작업을 반복한다
> 

**`예상 도착 시간 서비스` (ETA Service) :** 경로 계획 서비스가 최단 경로 목록을 수신하면, 예상 도착 시간 서비스를 호출하여 그 경로 각각에 대한 소요 시간 추정치를 구한다 → 이에 기반하여, 기계학습을 활용해 현재 교통 상황 및 과거 이력에 근거하여 ETA 계산

*까다로운 부분 - 실시간 교통 상황 데이터 + 앞으로의 교통상황이 어떻게 달라질지 예측해야 함

**`순위 결정 서비스` (ranker)** : 경로 계획 서비스에서 구한 ETA 예상치를 순위 결정 서비스에 전부 전달하고, 사용자가 정의한 필터링 조건을 적용

e.g. 유료 도로 제외, 고속도로 제외 등의 필터링 조건

→ 필터링이 끝나고 남은 경로를 **소요 시간 순**으로 정렬하여, 최단 시간 경로 k개를 구한 다음 경로 안내 서비스에 결과를 반환

**`중요 정보 갱신 서비스들`** : 카프카 위치 데이터 스트림을 구독하고 있다가 중요 데이터를 비동기적으로 업데이트하여 그 상태를 항상 최신으로 유지하는 역할

e.g.

- 경로 안내 타일 처리 서비스
    
    도로 데이터에 새로 발견된 도로, 폐쇄되었음이 확인된 도로 정보를 반영하여 경로 안내 타일을 지속적으로 갱신한다
    
    ⇒ 최단 경로 서비스에서 더 정확한 결과를 낼 수 있게 함!
    
- 실시간 교통 상황 서비스
    
    활성화 상태 사용자가 보내는 위치 데이터 스트림에서 교통 상황 정보 추출 → 그 결과로 찾아낸 정보는 **실시간 교통상황 데이터베이스**에 반영되며, 정확한 ETA를 산출하는 데 쓰인다
    

**`적응형 ETA와 경로 변경` :** 적응형 ETA와 경로 변경을 허용하기 위해, 서버는 현재 경로 안내를 받고 있는 모든 사용자를 추적하면서 교통 상황이 달라질 때마다 각 사용자의 ETA를 변경해줘야 함

[예상 질문] 

- 현재 경로 안내를 받고 있는 사용자를 어떻게 추적하는가?
- 수백만 경로 가운데 교통 상황 변화에 영향을 받는 경로와 사용자를 효율적으로 가려낼 방법이 무엇인가?

<aside>
🔎 특정 경로 안내 타일에서 교통사고가 발생했다고 가정할 때,

어떤 사용자가 영향을 받는지 알아내기 위해서 모든 레코드를 전수 조사하여 어떤 사용자가 해당 타일을 가지고 있는지 조사해야 한다

→ 이 테이블에 보관된 레코드 수가 n이고 안내되는 경로의 평균 길이가 m이라고 하면, **교통 상황 변화에 영향을 받는 모든 사용자 검색**의 시간복잡도는 ***O(nXm***) 이다

### 검색 속도를 향상시키자!

경로 안내를 받는 사용자 각각의 현재 경로 안내 타일, 그 타일을 포함하는 상위 타일(= 확대 수준이 더 낮은), 그 상위의 상위 타일까지…
”**출발지와 목적지가 모두 포함된 타일을 찾을 때까지 재귀적으로 더하여 보관하는 방식”**

[record example]

```jsx
user_1, r_1, super(r_1), super(super(r_1)), ...
```

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/80024278/64c51bfd-76db-4793-a2d8-2abbcab5d390)

- 경로 안내 ETA가 달라지는 사용자 : 해당 사용자의 데이터베이스 레코드 마지막 타일에 그 타일이 속하는 사용자
    
    *그 외 사용자에는 아무런 영향 X
    
- 검색 시간 복잡도 : O(nXm) → O(n)으로 향상!
</aside>

+) 교통 상황이 회복되어서 다시 그 길로 돌아갈 수 있는 상황까지 고려하면, 현재 경로 안내를 받는 사용자가 이용 가능한 경로의 ETA를 주기적으로 재계산하여 더 짧은 ETA를 갖는 경로가 발견되었을 때 알리는 방안이 있다

**`전송 프로토콜` :** 경로 안내 중 경로 상황이 변경되는 경우에, 데이터를 모바일 클라이언트에 안정적으로 전송하는 방법

→ 모바일 푸시 알림, 롱 폴링, 웹소켓, 서버 전송 이벤트 (SSE) 등

- 모바일 푸시 알림 : 전송 가능한 메시지 크기 매우 제한적(e.g. iOS - 최대 4906byte), 웹 애플리케이션 지원 X
- WebSocket : 실시간 양방향 통신 지원 (서버에 부담을 크게 주지 않아, 롱 폴링보다 좋은 방안)
    - 패키지나 상품이 목적지에 가까워진 상황 등

### 최종 설계안

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/80024278/91929ead-dceb-404f-b133-e18bd14d56df)

## 4단계 마무리

[시스템의 확장 요소]

- 기업 고객 대상으로 중간 경유지 설정 기능 제공
    
    여러 목적지가 입력으로 들어올 때, 어떤 순서로 방문해야 가장 빨리 경유할 수 있는가
    
- 도어대시(Door-Dash), 우버(Uber), 리프트(Lyft)와 같은 배달 서비스에 유용

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/80024278/90e2a09d-af8f-4d26-ad1b-1855ffcfe66c)
