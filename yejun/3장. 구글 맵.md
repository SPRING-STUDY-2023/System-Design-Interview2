# 3장. 구글 맵
## About 구글 맵

> 위성 이미지, 거리 뷰, 실시간 교통 상황, 경로 계획 등 다양한 서비스를 제공
> 

⇒ 사용자가 목적지와 경로를 찾을 수 있도록 돕는다

- DAU 10억 명
- 전 세계 99% 지역의 지도 제공
- 매일 2500만 건의 업데이트 반영 → 정확한 실시간 위치 정보를 제공하기 위함

## 1단계 문제 이해 및 설계 범위 확정

**[요구사항 파악하기]**

- DAU : 10억 명으로 가정
- Focusing 해야 할 주요 기능
    
    **위치 갱신**, 방향 안내, **경로 안내**, **예상 도착 시간(ETA)**, **지도 표시** 등
    
- 데이터 규모
    - 도로 데이터 : 수 TB 수준의 가공되지 않은 데이터 (다양한 경로를 확보했다고 가정)
- 고려사항
    - 교통 상황 : 도착 시간을 정확하게 추정하는 데 매우 중요 ⭐
    - 이동 수단 : 운전, 대중교통, 도보 등 다양한 이동 방법을 지원해야 함
    
    *고려하지 않는 것
    
    - 경로 안내 시 경유지 설정 → 고려X
    - 사업장 위치 및 사진 표시, 최대 허용되는 사진 수  → 고려X

### 기능 요구사항

[주요 기능]

1. 사용자 위치 갱신
2. 경로 안내 서비스 (ETA 서비스 포함)
3. 지도 표시

[지원할 주 단말]

모바일 전화기 (스마트폰)  *데이터 사용량과 배터리 효율을 중시

### 비기능 요구사항 및 제약사항

- `정확도` : 사용자에게 잘못된 경로를 안내해서는 안 됨
- `부드러운 경로 표시` : 클라이언트를 통해 제공되는 경로 안내 용도의 지도는 아주 부드럽게 표시되고 갱신되어야 함
- `데이터 및 배터리 사용량` : 클라이언트는 가능한 한 최소한의 데이터와 배터리를 사용해야 함   *모바일 단말에 중요한 요구사항
- `가용성`
- `규모 확장성`

### 지도 101

- 측위 시스템
    
    > 구 표면 상의 위치를 표현하는 체계
    > 
    - 위도(latitude) : 주어진 위치가 얼마나 북쪽/남쪽인지
    - 경도(longitude) : 얼마나 동쪽/서쪽인지

- 3차원 위치의 2차원 변환
    
    > [지도 투영법](https://ko.wikipedia.org/wiki/%EC%A7%80%EB%8F%84_%ED%88%AC%EC%98%81%EB%B2%95)(map projection) / 도법 : 3차원 구 위의 위치를 2차원 평면에 대응시키는 절차
    > 
    
    *거의 모든 투영법은 실제 지형의 기하학적 특성을 왜곡한다
    
    <aside>
    📌 구글 맵은 메르카토르 도법을 조금 변경한 웹 메르카토르(Web Mercator) 도법을 사용중!
    
    </aside>
    
- 지오코딩(Geocoding)
    
    > 주소를 지리적 측위 시스템의 좌표로 변환하는 프로세스
    > 
    - 미국 내 주소 ‘1600 Amphitheatre Parkway, Mountain View, CA’ <=> (위도 37.423021, 경도 -122.083739)
    - `역 지오코딩` : 지오코딩 결과 → 반대로 주소로 변환하는 프로세스
    
    [방법]  인터폴레이션(interpolation)
    
    GIS(Geographic Information System)와 같은 다양한 시스템이 제공하는 데이터를 결합한다는 뜻
    

- 지오해싱(Geohashing)
    
    > 지도 위 특정 영역을 영문자와 숫자로 구성된 짧은 문자열에 대응시키는 인코딩 체계
    > 
    
    → 2차원의 평면 공간으로 표현된 지리적 영역 위의 격자를 더 작은 격자로 재귀적으로 분할해 나감
    
    - 각 격자는 정사각형 / 사각형
    - 어떤 격자를 재귀적으로 분할한 결과로 더 작은 격자가 생성되고, 이는 0~3의 번호가 부여됨
    
    [용도]  맵 타일 관리
    
- 지도 표시
    
    > `타일(tile)` : 지도 전부를 하나의 이미지로 표시하는 대신, 작은 타일로 쪼개어 표시하는 것
    > 
    - 타일은 지도를 화면에 표시하는 데 가장 기본적인 개념
    - 클라이언트는 사용자가 보려는 영역에 관계된 타일만 다운받아 모자이크처럼 이어 붙인 다음 화면에 뿌림
    - **지도 확대/축소 기능**과 연관 - 지도 확대 수준(zoom level)에 따라 어떤 크기의 타일을 가져올지 고르는 방식
        
        → 사용자가 전체 지도를 한눈에 다 보는 경우, 수십만 타일을 전부 다운로드할 필요는 없음 (전체를 256X256 픽셀 이미지 하나로 표현하는 지도 한 장으로 충분!)
        
    
- 경로 안내 알고리즘을 위한 도로 데이터 처리
    
    > Dijkstra 알고리즘, A* 경로 탐색 알고리즘 활용 → 그래프 자료구조 [교차로 = Node, 도로 = Edge]
    > 
    - 대부분의 경로 탐색 알고리즘은 **그래프 크기**에 아주 민감
        - 전 세계 도로망을 하나의 그래프로 표현하기에는, 메모리 차지와 경로 탐색 성능 측면에서 만족스럽지 않을 것임!
        - 설계안에서 가정하는 규모에도 좋은 성능을 보이려면 그래프를 **관리 가능 단위**로 분할할 필요가 있음
            
            
    
    <aside>
    🌐 `타일 기반 분할법`과 유사 : 세계를 작은 격자로 나누고, 각 격자 안의 도로망을 노드(교차로)와 선(도로)으로 구성된 그래프 자료 구조로 변환
    
    - 각 격자는 경로 안내 타일(routing tile)이라 부름
    - 각 타일은 도로로 연결된 다른 타일에 대한 참조를 유지
    
    ⇒ 연결된 타일들을 지나갈 때 보일 더 큰 도로망 그래프를 만들어낼 수 있고, 
    도로망을 언제든 불러올 수 있는 경로 안내 타일로 분할해 놓음으로써 **메모리 요구량**을 낮추고, 한번에 처리해야 하는 경로의 양이 줄어들어 **경로 탐색 성능**도 좋아진다
    
    </aside>
    
- 계층적 경로 안내 타일
    
    > 경로 안내가 효과적으로 동작하기 위해, 필요한 수준의 구체성을 갖춘 도로 데이터가 필요하다
    > 
    
    이 구체성 정도를 상/중/하로 구분하여, 3가지 종류의 경로 안내 타일을 준비한다
    
    - `상` : 가장 구체성이 높은 타일로, 크기가 매우 작음 → 지방도(local roads) 데이터
    - `중` : 더 넓은 지역을 커버하며, 규모가 비교적 큼 → 관할구(district)를 잇는 간선 도로 데이터
    - `하` : 구체성이 가장 낮은 타일로, 큰 영역을 커버함 → 도시와 주를 연결하는 주요 고속도로 데이터
    

### 개략적 규모 추정

<aside>
📏 [참고] 도량형 변환 규칙

- 1피트 = 0.3048미터
- 1킬로미터 = 0.6241마일 = 1000미터
</aside>

- 저장소 사용량
    
    
    | 세계 지도 | 지원하는 확대 수준별로 지도 타일을 한 벌씩 두고, 지도를 최대 확대했을 때의 전부 보관하는 데 필요한 타일 개수를 따져봐야 함 ex. 1장의 타일=256X256픽셀 압축 PNG 파일일 때, 1장당 100KB의 저장공간이 필요하므로, 최대 확대 시 총 4.4조X100KB=440PB 만큼의 저장공간이 필요할 것. |
    | --- | --- |
    | 메타데이터(metadata) | 각 지도 타일의 메타데이터는 크기가 아주 작아서 무시해도 지장 無 |
    | 도로 정보 | (가정)외부에서 받은 수 TB 용량의 도로 데이터 → 경로 안내 타일로 변환 (용량은 변환 전후 큰 차이가 없을 것) |
- 서버 대역폭
    
    [요청의 유형]
    
    1. **경로 안내 요청** : 클라이언트가 경로 안내 세션을 시작할 때 전송하는 메시지
        
        ex. 각 사용자가 경로 안내 기능을 평균적으로 주당 35분 사용한다고 가정할 때, (DAU는 10억 명으로 가정)
        
        주당 350억 분, 하루에 50억 분
        
        <aside>
        ❗ <b>QPS</b>
        
        1. GPS 좌표를 매초 전송하기
            
            하루에 3000억 건의 요청이 발생하고(50억 분 X 60) 이는 3백만 QPS에 해당 (3000억 건의 요청/10^3 = 3백만)
            
        2. 요청을 클라이언트 쪽에 모아 두었다가 덜 자주 보내도록 하기(15초 or 30초마다 한 번씩) ✅
            
            쓰기 QPS를 낮출 수 있음  *요청 빈도는 사용자의 이동 속도 등 다양한 요건에 의해 결정
            
            ex. 사용자가 꽉 막힌 도로에 있는 경우, GPS 위치 업데이트를 자주 보낼 필요가 없기 때문
            
        
        🟢 본 설계안의 경우, GPS 위치 변경 내역은 모아두었다가 15초마다 한 번씩 서버로  
        
        </aside>
        
    2. **위치 갱신 요청** : 클라이언트가 경로 안내를 진행하는 동안 변경된 사용자 위치를 전송하는 메시지
        
        → 구글 맵 서비스에서는 이 위치 정보를 **실시간 교통상황 데이터 계산 과정의 입력**과 같이 다양한 방식으로 이용
        
        *GPS 위치 변경 내역은 모아두었다가 15초마다 한 번씩 서버로 보낸다고 가정 
        
        > 위치 정보 갱신 요청 최대 QPS = 200,000 X 5 = 1백만
        > 
    

## 2단계 개략적 설계안 제시 및 동의 구하기

![IMG_7408.jpg](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/a8593c94-0847-4614-96a9-464c446eba20)

1. 위치 서비스(location service)
2. 경로 안내 서비스(navigation service)
3. 지도 표시(map rendering)

### 위치 서비스

> 사용자의 위치를 기록하는 역할
> 

[가정] 위치 변경 내역은 매초 측정하되, 클라이언트가 t초마다 자기 위치를 전송한다  (t는 설정 가능한 값)

<aside>
⭐ **주기적으로 위치 정보를 전송하는 방식의 장점**

1. 해당 데이터 스트림을 활용하여 시스템을 점차 개선할 수 있다
    - 실시간 교통 상황 모니터링
    - 새로 만들어진 도로나 폐쇄된 도로 탐지
    - 사용자 행동 양태 분석을 통해 개인화된 경험 제공
2. 클라이언트가 보내는 위치 정보(실시간 정보)의 ETA를 보다 정확하게 산출할 수 있고, 교통 상황에 따라 다른 경로를 안내할 수도 있다
</aside>

사용자의 위치가 바뀔 때마다 그 즉시 서버로 전송해야 하는 건 아니므로, 위치 이력을 클라이언트에 버퍼링해 두었다가 일괄 요청(batch request)하면 전송 빈도를 줄일 수 있다

![IMG_7418.jpg](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/a9b576c0-eeec-47c6-a98f-7d042d8fe150)

갱신 요청 빈도를 줄여도 여전히 높은 쓰기 요청 빈도를 가지는 구글 맵 시스템은 아래와 같은 설계를 고려해볼 수 있다.

- 카산드라(Cassandra) 데이터베이스 - 높은 빈도의 쓰기 요청에 최적화, 규모 확장 용이
- 카프카(Kafka) 스트림 처리 엔진 - 위치 데이터 로깅
- HTTP 통신 프로토콜
    - keep-alive 옵션
    - 형태
        
        ```json
        POST /v1/locations
        인자: 
        locs: JSON으로 인코딩한 (위도, 경도, 시각) 순서쌍 배열
        ```
        

### 경로 안내 서비스

> A에서 B 지점으로 가는 합리적으로 빠른 경로를 찾아주는 역할
> 

*결과를 얻는 데 드는 시간 지연은 어느 정도 감내할 수 있다

- ❗계산된 경로는 최단시간 경로일 필요는 없으나, 정확도는 보장되어야 한다

`GET`  /v1/nav?origin=1355+market+street,SF&description=Disneyland

출발지와 목적지를 인자로 전달한 API 요청을 보내면, 로드밸런서를 거쳐 서비스에 도달한다 

```json
{
	'distance': {'text': '0.2 mi', 'value': 259},
	'duration': {'text': '1 min', 'value': 83},
	'end_ location': {'lat': 37.4038943, 'Ing': -121.9410454},
	'html_instructions': 'Head <b>northeast</b> on <D>brandon St</bs
			toastreaumin waye/Bad sty le font-saze： .Serl Restitea
			usage roads/div»,
	'polyline': {'points': '_fhcFjbhgVuAwDsCal'},
	'start_ location': {'lat': 37.4027165, '1ng': -121.9435809},
	'geocoded_waypoints': [
	{
			"geocoder _status" : "OK",
			"partial_match" : true,
			"place_id" : "ChIJwZN™t¡1fawwRO2aVVVX2yKg",
			"types" : [ "locality", "political" ]
	},
	{
			"geocoder_status" : "OK",
			"partial_match" : true,
			"place_id" : "ChIJaPgQGtXawwRLYe¡B™U¡7b™",
			"types" : [ "locality", "political" ]
	}
	],
	'travel_ mode': 'DRIVING'
}
```

→ 경로 재탐색이나 교통 상황 변화 같은 문제는 적응형 ETA (adaptive ETA)를 통해 해결 가능

### 지도 표시

클라이언트가 모든 확대 수준별 지도 타일을 저장하는 건 비효율적이므로, **클라이언트의 위치 및 현재 클라이언트가 보는 확대 수준에 따라 필요한 타일을 서버에서 가져오는 접근법**이 바람직하다

> [Scenario] 언제 지도 타일을 서버에서 가져오는가?
> 

I. 사용자가 지도를 확대 또는 이동시키며 주변을 탐색한다

II. 경로 안내가 진행되는 동안 사용자의 위치가 현재 지도 타일을 벗어나 인접한 타일로 이동한다

> [Choice] 다량의 지도 타일 데이터를 서버에서 효과적으로 가져오려면?
> 

Case I. 클라이언트의 위치, 현재 클라이언트가 보는 지도의 확대 수준에 근거하여 필요한 지도 타일을 즉석에서 만드는 방안

→ ⚠️ BUT 사용자의 위치 및 확대 수준의 조합은 무한하다

- 모든 지도 타일을 동적으로 만들어야 하는 서버 클러스터에 심각한 부하가 걸린다
- 캐시를 활용하기가 어렵다

Case II. 확대 수준별로 미리 만들어 둔 지도 타일을 클라이언트에 전달하기만 하는 방법

→ 각 지도 타일이 담당하는 지리적 영역 : 지오해싱 같은 분할법을 사용해 만든 고정된 사각형 격자로 표현되므로 정적(static)

- 클라이언트는 지도 타일이 필요할 경우, 현재 확대 수준에 근거하여 필요한 지도 타일 집합을 결정한다
- 그 다음, 각 위치를 지오해시 URL로 변환한다

<aside>
📌 CDN을 통한 사전 생성된 지도 이미지 서비스

1. 모바일 단말 사용자는 지도 타일 요청을 CDN에 보냄
2. 해당 타일이 CDN을 통해 서비스된 적이 없는 경우, CDN은 원본 서버에서 해당 파일을 가져와 그 사본을 캐시에 보관한 다음 사용자에게 반환함
3. 그 뒤로 다른 사용자가 같은 파일을 요청하면 CDN은 캐시에 보관한 사본을 서비스하며, 원본 서버는 다시 접촉하지 않음

👍🏻 규모 확장에 용이하고 성능 측면에서도 유리함 (사용자에게 가장 가까운 POP(Point Of Presense)에서 파일을 서비스하기 때문)

![IMG_7419.jpg](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/80c5fffd-34de-498d-bdf2-67cb73e04c8d)

→ ***지도 타일은 정적이므로 캐시를 통해 서비스하기에 아주 적합!***

<aside>
✔️ 데이터 사용량

> 경로 안내를 진행하는 동안 클라이언트가 일반적으로 필요로 하는 데이터 양을 계산해보자 (단, 클라이언트 측 캐시는 고려하지 않는다)
> 
- 클라이언트에 캐시를 두면? 사람들은 일반적으로 같은 길을 이용하는 경향이 있으므로, 훨씬 데이터 사용량을 줄일 수 있을 것!

[가정] 사용자가 30km/h 속도로 이동 중, 한 이미지는 200mX200m 영역을 표현하도록 확대하여 지도를 표시하고 있는 상황

- 이미지 1장 : 256X256픽셀
- 평균 이미지 크기 : 100KB

1kmX1km 영역을 표현하려면 이미지 25장이 필요하다 → 이를 저장용량으로 환산하면 2.5MB(25X100KB)

ex. 30km/h 속도로 이동한다고 할 때, 시간당 75MB의 데이터가 소진되며(30X2.5MB), 이는 분당 1.25MB에 해당

</aside>

<aside>
✔️ CDN을 통해 서비스되는 트래픽 규모

매일 50억 분 가량의 경로 안내를 처리한다고 가정할 때, 이는 50억 X 1.25MB = 6.25PB/일에 해당하는 양이다

⇒ 초당 전송해야 하는 지도 데이터의 양 : 62,500MB (6.25PB/10^5초/하루)

CDN을 사용하면 지도 이미지는 전 세계에 흩어져 있는 POP를 통해 제공될 것이며, 전 세계에 200개의 POP가 있다고 가정할 때, 각 POP는 수백(62,500/200) MB 정도의 트래픽만 처리하면 된다 

</aside>

</aside>

> 클라이언트는 CDN에서 지도 타일을 가져올 URL을 어떻게 결정할까?
> 

지도 타일은 이미 정의된 격자에 맞게 확대 수준별로 한 벌씩 미리 만들어 둔 것을 사용한다

→ 지오해시를 사용해서 격자를 나누므로, 모든 격자는 고유한 지오해시 값을 가진다.

[계산방식] 위도/경도로 표현된 클라이언트 위치 및 현재 지도 확대 수준을 INPUT으로 → 화면에 표시할 지도 타일에 대응되는 지오해시 계산(클라이언트에서 수행) → 해당 지오해시 및 URL로 CDN에서 지도 타일을 가져옴

ex. https://cdn.map-provider.com/tiles/9q9hvu.png

### ETC

[주의사항]

⚠️ 지오해시 계산 알고리즘을 클라이언트가 수행해도 되지만, 지원해야 할 플랫폼이 많을 때 문제가 될 수 있으므로 주의하자

⚠️ 모바일 앱 업데이트 배포는 시간이 오래 걸리고 때로는 위험한 프로세스임 ⇒ **맵 타일 인코딩에 지오해싱을 사용한다는 보장이 있어야 한다**

[기타 고려사항]

주어진 위도/경도 및 확대 수준을 타일 URL로 변환하는 알고리즘은 별도 서비스에 두는 것을 고려해볼 수 있다

→ 사용자가 새로운 위치로 이동하거나 확대 수준을 변경하면, 위도, 경도, 현재 확대 수준을 입력으로 하여 타일 URL을 계산하는 역할을 담당하는 간단한 서비스

![IMG_7420.jpg](https://github.com/SPRING-STUDY-2023/System-Design-Interview/assets/80024278/566c2440-9e0d-4743-8f52-faa340c950de)

1. 모바일 사용자가 타일 URL들을 가져오기 위해 지도 타일 서비스를 호출한다 (이 요청은 로드밸런서로 전달)
2. 로드밸런서는 해당 요청을 지도 타일 서비스로 전달한다
3. 지도 타일 서비스는 클라이언트의 위치와 확대 수준을 입력으로 삼아 9개의 타일 URL을 계산한 다음 클라이언트에 반환한다 (표시할 타일 하나의 8개의 주변 타일이 응답에 포함됨)
4. 모바일 클라이언트는 해당 타일을 CDN을 통해 다운로드한다
