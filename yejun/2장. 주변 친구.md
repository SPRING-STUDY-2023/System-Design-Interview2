# 2장. 주변 친구
*주변 친구(nearby friends)라는 모바일 앱 기능을 지원하는 규모 확장이 용이한 백엔드 시스템을 설계해보자!*

→ 앱 사용자 중 본인 위치 정보 접근 권한을 허락한 사용자애 한해 인근의 친구 목록을 보여주는 시스템

🧐  [1장 근접성 서비스](https://github.com/SPRING-STUDY-2023/System-Design-Interview2/blob/main/yejun/1%EC%9E%A5%20%EA%B7%BC%EC%A0%91%EC%84%B1%20%EC%84%9C%EB%B9%84%EC%8A%A4.md) 와 차이가 있다면?!

- 근접성 서비스의 **주소** : 정적(static)
- 주변 친구의 **위치** : 동적(dynamic)


## 1단계 문제 이해 및 설계 범위 확정

- ‘주변’의 지리적 기준
    - 5 mile(8km) 이내에 위치할 때
    - 이 수치는 직접 설정 가능
    - 두 사용자 간의 직선 거리 기준 (실제 이동 거리는 배제)
- 앱 이용자 수
    - 10억 명 가정, 그 중 10% 정도가 해당 기능 이용
- 사용자의 이동 이력
    - 보관 O (기계 학습 등 다양한 용도로 활용될 수 있음)
- 사용자의 활성 상태
    - 친구 관계에 있는 사용자가 10분 이상 비활성 상태일 때, 해당 사용자를 주변 친구 목록에서 사라지게 설정
    - ~~마지막으로 확인한 위치 표시~~
- 사생활 및 데이터 보호법 준수
    - 풀이 과정이 너무 복잡해질 수 있으니, 일단은 배제 (but, 좋은 접근임!)

### 기능 요구사항

- 사용자는 모바일 앱에서 주변 친구를 확인할 수 있어야 함
    
    [주변 친구 목록]
    
    - 해당 친구까지의 거리
    - 해당 정보가 마지막으로 갱신된 시각(timestamp)
- 친구 목록은 몇 초 단위로 갱신

### 비기능 요구사항

- 낮은 지역 시간 : 주변 위치의 위치 변화가 반영되는 데 너무 오랜 시간 X
- 안정성 : 전반적으로 안정적이지만, 때로 몇 개의 데이터가 유실되는 정도는 용인 가능
- 결과적 일관성 : 복제본의 데이터가 원본과 동일하게 변경되기까지 몇 초 정도 소요되는 정도는 용인 가능
    
    (위치 데이터를 저장하기 위해 강한 일관성을 지원하는 데이터 저장소까지 사용할 필요는 X)
    

### 개략적 규모 추정

- `주변 친구` : 5마일(8km) 반경 이내 친구로 정의
- `친구 위치 정보` : 30초 주기로 갱신
    
    → 사람이 걷는 속도가 3~4마일(4~6km/h) 정도로 느리기 때문
    
- `DAU` : 평균적으로 매일 주변 친구 검색 기능을 활용하는 사용자는 1억 명으로 가정
- `동시 접속 사용자 수` : DAU 수의 10%(천만 명)로 가정
- `사용자당 평균 친구 수` : 평균적으로 400명의 친구를 가지고, 모두 주변 친구 검색 기능을 활용한다고 가정
- `페이지당 표시 친구 수` : 이 기능을 제공하는 앱은 페이지당 20명의 주변 친구를 표시하고, 사용자의 요청이 있으면 더 많이 표시할 수 있음

<aside>
📏 QPS 계산

- 1억 DAU
- 동시 접속 사용자 : 10% X 1억 = 천만
- 사용자는 30초마다 자기 위치를 시스템에 전송

⇒ 위치 정보 갱신 QPS = 천만/30 =~ **334,000**

</aside>

## 2단계 개략적 설계안 제시 및 동의 구하기

### 개략적 설계안

위치 정보는 모든 친구에게 전송(push)해야 하므로, 단순한 HTTP 프로토콜을 사용하기 어렵다. 

그렇다면, 어떻게 메시지를 효과적으로 전송할 수 있을까?

1. P2P(peer-to-peer) 방식
    
    > 사용자는 근방의 모든 활성 상태 친구의 새 위치 정보를 수신하고자 한다.
    > 
    
    ⇒ 활성 상태인 근방 모든 친구와 **항구적 통신 상태** 유지하기
    
    ![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/80024278/ce85bdcb-7073-4162-92e7-8439ade41a5d)
    
    - 단말에 따른 통신 연결 상태, 사용 가능한 전력의 불충분 등 실용적인 아이디어는 아니지만, 초기 방향성을 이에 기반하여 잡아보자!
    
2. 공용 백엔드 사용 방식
    
    [백엔드의 역할]
    
    - 모든 활성 상태 사용자의 위치 변화 내역을 수신한다.
    - 사용자 위치 변경 내역을 수신할 때마다 해당 사용자의 모든 활성 상태 친구를 찾아서 그 친구들의 단말로 변경 내역을 전달한다.
    - 두 사용자 사이의 거리가 특정 임계치보다 먼 경우에는 변경 내역을 전송하지 않는다.
    
    <aside>
    🚨 *대규모 트래픽을 처리하기에는 무리가 있다 ..*
    
    활성 상태의 동시 접속 사용자가 천만 명 정도로 전제되었기 때문에 모두가 자기 위치 정보를 30초마다 갱신한다고 했을 때 무려 초당 334,000번의 위치 정보 갱신을 처리해야 하므로 과부하를 일으킬 수 있다
    
    평균적으로 사용자 1명이 `400명`의 친구를 가지고, 그 중 `10%`가 인근에서 활성화 상태일 때,
    
    **초당 334,000 X 400 X 10% = 1400만 건**의 위치 정보 갱신 요청을 처리해야 한다
    
    </aside>
    

![IMG_6608.jpg](https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/80024278/3bfa31b2-efa6-4dcd-8d61-520429cc3305)

`레디스 위치 정보 캐시` : 활성 상태 사용자의 가장 최근 위치 정보를 캐시하는 데 사용

→ 캐시 항목 중 TTL(Time-To-Live) 필드를 통해 기간이 지나면 해당 사용자가 비활성 상태로 바뀌고, 그 위치 정보가 캐시에서 삭제되도록 함

- 캐시 정보 갱신 시, TTL도 함께 갱신

*레디스 외에도 TTL을 지원하는 키-값 저장소는 캐시로 활용 가능!

`사용자 데이터베이스` : 사용자 데이터 및 사용자의 친구 관계 정보 저장 

- 관계형 DB, NoSQL 모두 사용가능

`위치 이동 이력 데이터베이스` : 사용자의 위치 변동 이력 보관

- 주변 친구 표시와 직접 관계된 기능 X

`레디스 pub/sub 서버` : 초경량 메시지 버스(message bus)

- 레디스 pub/sub에 새로운 채널(topic)을 생성하는 것은 매우 값싼 연산 ⇒ 기가바이트급 메모리를 갖춘 최신 레디스 서버의 경우, 수백만 개의 채널 생성 가능

`로드밸런서` : RESTful 서버 및 양방향 유상태(stateful) 웹소켓 서버 앞단에 위치

→ 부하를 고르게 분산하기 위해 트래픽을 서버들에 배분하는 역할

`RESTful API 서버` : 무상태(stateless) API 서버의 클러스터로, 통상적인 요청/응답 트래픽을 처리

- 친구 추가/삭제
- 사용자 정보 갱신

`웹소켓 서버` : 친구 위치 정보 변경을 거의 실시간에 가깝게 처리하는 유상태 서버 클러스터

→ 각 클라이언트는 그 중 한 대와 웹소켓 연결을 지속적으로 유지함

- 검색 반경 내 친구 위치가 변경되면 해당 내역은 이 연결을 통해 클라이언트로 전송됨
- 주변 친구 기능을 이용하는 클라이언트의 초기화 담당
- 온라인 상태인 모든 주변 친구 위치를 해당 클라이언트로 전송하는 역할

<aside>
📌 Redis pub/sub의 동작 원리

![Untitled](https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/80024278/be9411f8-6122-4c31-a814-de1c19cd117e)

***publisher*** : 위치 정보가 갱신되었다는 이벤트를 발행(publish)하려는 사용자들

***subscriber*** : 구독 관계의 친구들

1. 웹소켓 서버를 통해 수신한 특정 사용자의 위치 정보 변경 이벤트는 해당 사용자에게 배정된 pub/sub 채널에 발행한다
2. 해당 사용자의 친구 각각과 연결된 웹소켓 연결 핸들러는 해당 채널의 구독자로 설정되어 있다
3. 특정 사용자의 위치가 바뀌면 해당 사용자의 모든 친구의 웹소켓 연결 핸들러가 호출된다
4. 각 핸들러는 위치 변경 이벤트를 수신할 친구가 활성 상태면 → 거리를 다시 계산
5. 새로 계산한 거리가 검색 반경 이내면 → 갱신된 위치와 갱신 시각을 웹소켓 연결을 통해 해당 친구의 클라이언트 앱으로 전송
</aside>

> 사용자의 위치가 변경되면 무슨 일이 일어날까?
> 

**[시스템 관점 - 주기적 위치 갱신]**

1. `모바일 클라이언트`가 위치가 변경된 사실을 로드밸런서에 전송
2. `로드밸런서`는 그 위치 변경 내역을 해당 클라이언트와 웹소켓 서버 사이에 설정된 연결을 통해 웹소켓 서버로 전송
3. `웹소켓 서버`는 해당 이벤트를 위치 이동 이력 데이터베이스에 저장
4. `웹소켓 서버`는 새 위치를 위치 정보 캐시에 보관 → 이때, TTL도 새롭게 갱신하고, 웹소켓 서버는 웹소켓 연결 핸들러 안의 변수에 해당 위치를 반영함
5. `웹소켓 서버`는 레디스 pub/sub 서버의 해당 사용자 채널에 새 위치를 발행 

(STEP 3~5는 병렬적으로 수행)

1. 레디스 pub/sub 채널에 발행된 새로운 위치 변경 이벤트는 모든 구독자(즉, 웹소켓 이벤트 핸들러)에게 broadcast 됨 
    
    *구독자 = 위치 변경 이벤트를 보낸 사용자의 온라인 상태 친구들
    
    → 각 구독자의 웹소켓 이벤트 핸들러는 친구의 위치 변경 이벤트를 수신하게 됨
    
2. 메시지를 수신한 해당 웹소켓 서버는 새 위치를 보낸 사용자~메시지를 받은 사용자 사이의 거리를 새로 계산함
3. 만일 계산한 거리가 검색 반경을 넘지 않는다면 → 새 위치 및 해당 위치로의 이동이 발생한 시각을 나타내는 타임스탬프를 해당 구독자의 클라이언트 앱으로 전송 
    
    초과한다면 → 전송하지 않음
    

***→ ❗모바일 클라이언트는 항구적으로 유지되는 웹소켓 연결을 통해 주기적으로 위치 변경 내역을 전송한다***

<aside>
👭 사례를 통해 이해해보자!

![IMG_6609.jpg](https://github.com/SPRING-STUDY-2023/System-Design-Interview2/assets/80024278/3c71c06b-a59c-4d75-afe6-48880b3e74e0)

- 사용자 1의 친구 : 사용자 2, 3, 4
- 사용자 5의 친구 : 사용자 4, 6

**[모든 구독자에 반복 적용되는 계산 Flow]**

1. 사용자 1의 위치가 변경되면 → 그 변경 내역은 사용자 1과의 연결을 유지하고 있는 웹소켓 서버에 전송됨
2. 해당 변경 내역은 레디스 pub/sub 서버 내의 사용자 1 전용 채널로 publish 됨
3. 레디스 pub/sub 서버는 해당 변경 내역을 모든 구독자에게 broadcast 함
    
    → 이때 구독자는 사용자 1과 친구 관계에 있는 모든 웹소켓 연결 핸들러 (사용자 2, 3, 4)
    
4. 위치 변경 내역을 보낸 사용자와 구독자 사이의 거리 (사용자 1~2)가 검색 반경을 넘지 않는다면, 새로운 위치가 사용자 2의 클라이언트로 전송됨

→ 이는 문제에서 가정한 상황에 대입해보면, 한 사용자 위치 정보가 바뀔 때마다 위치 정보 전송이 40건 정도 발생하게 된다

</aside>

### API 설계

> `웹소켓` : 사용자는 웹소켓 프로토콜을 통해 위치 정보 변경 내역을 송수신한다
> 

[서버 API]

1. 주기적인 위치 정보 갱신 API
    - Request : 위도, 경도, 시각 정보
    - Response : X
2. 웹소켓 초기화 API
    - Request : 위도, 경도, 시각 정보
    - Response : 본인 친구들의 위치 데이터

[클라이언트 API]

1. 클라이언트가 갱신된 친구 위치를 수신하는 데 사용할 API
    - Response : 친구 위치 데이터, 변경된 시각을 나타내는 타임스탬프
2. 새 친구 구독 API
    - Request : 친구 ID (웹소켓 서버)
    - Response : 가장 최근의 취도, 경도, 시각 정보
3. 구독 해지 API
    - Request : 친구 ID (웹소켓 서버)
    - Response : X

[HTTP 요청]

API 서버는 친구를 추가/삭제하거나 사용자 정보를 갱신하는 등의 작업을 처리한다

### 데이터 모델

> `위치 정보 캐시` : ‘주변 친구’ 기능을 켠 활성 상태 친구의 가장 최근 위치를 보관
> 
- 본 설계안에서는 Redis로 구현
- 캐시에 보관되는 데이터 형태
    
    
    | 키 | 값 |
    | --- | --- |
    | 사용자 ID | { 위도, 경도, 시각}  |

<aside>
🙋🏻‍♀️ 위치 정보를 저장하는 데 DB를 사용하지 않는 이유는?!

*‘주변 친구’ 기능은 **현재 위치**만을 이용하므로, 하나만 보관해도 충분하다!*

- 영속성 보장할 필요 X
- 비활성 상태 주기적으로 삭제 (by TTL)

→ 이러한 경우에 읽기/쓰기 연산 속도가 빠른 Redis가 매우 적합! 

⚠️ 레디스 서버 하나에 장애가 발생한다면?

다른 새 서버로 바꾼 다음, 갱신된 위치 정보가 캐시에 데워지기(warmed up, 채워지기)를 기다리면 충분하다. 갱신 주기를 한 두 번 skip 하는 동안 활성상태인 친구의 위치 변경 내역을 놓칠 수도 있겠지만 이 정도의 문제는 용인 가능하므로, 시간이 남을 때 캐시 교체 시점에서의 발생 가능한 문제를 줄이는 방안을 고려해보자

</aside>

> `위치 이동 이력 데이터베이스` : 사용자의 위치 정보 변경 이력을 테이블에 아래와 같이 저장
> 

| user_id | latitude | longitude | timestamp |
| --- | --- | --- | --- |
- 막대한 쓰기 연산 부하 감당
- 수평적 규모 확장 가능

이력 데이터의 양은 서버 한 대에 보관하기에 매우 많을 수 있으므로, 사용자 ID를 기준 삼는 샤딩 방안을 고려해볼 수 있다.
