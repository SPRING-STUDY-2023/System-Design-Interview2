# 8장. 분산 이메일 서비스

> Gmail, Outlook, Yahoo! Mail과 같은 대규모 이메일 서비스를 설계해보자
> 

## 1단계  문제 이해 및 설계 범위 확정

- `사용자 규모` : 10억 명
- `주요 기능`
    - ~~인증~~ (skip)
    - 이메일 발송/수신
    - 모든 이메일 가져오기
    - 읽음 여부에 따른 이메일 필터링
    - 제목, 발신인, 메일 내용에 따른 검색 기능
    - 스팸 및 바이러스 방지 기능
- `메일 서버 연결 방식`
    - HTTP 프로토콜을 사용한다고 가정
    - ***legacy*** - SMTP, POP, IMAP 등의 프로토콜과 서비스 제공자 전용 프로토콜을 사용해 접속

### 비기능 요구사항

- `안정성` : 이메일 데이터의 소실 X
- `가용성` : 이메일과 사용자 데이터를 여러 노드에 자동으로 복제하여 가용성 보장
- `확장성` : 사용자, 이메일 수가 늘어나도 시스템 성능 저하 X
- `유연성` : 새 컴포넌트로 쉽게 기능 추가 및 성능 개선이 가능한 환경
    
    *전통적 이메일 프로토콜은 기능이 매우 제한적이기 때문
    

### 개략적인 규모 추정

- 10억 명의 사용자
- 이메일 건수
    - 한 사람이 하루에 보내는 평균 이메일 수 : 10건
        
        $$
        이메일\ 전송\ QPS=\frac{10^9X10}{10^5}=100,000
        $$
        
    - 한 사람이 하루에 수신하는 평균 이메일 수 : 40건
- 이메일 1건의 메타데이터 평균 크기 : 50KB
    - 주어진 이메일에 대한 모든 정보 기준 (첨부파일 포함X)
    - DB에 저장
    - 1년간 메타데이터를 유지하기 위한 스토리지 요구사항
        
        $$
        10억\ 명\ 사용자X하루\ 40건의\ 이메일X365일X50KB=730PB
        $$
        
- 첨부파일 포함 이메일 비율 : 20%, 평균 크기 : 300KB
    - 1년간 첨부파일을 보관하는 데 필요한 저장 용량
        
        $$
        10억\ 명\ 사용자X하루\ 40개 이메일X365일X20\%X500KB = 1,460PB
        $$
        

## 2단계  개략적 설계안 제시 및 동의 구하기

### 이메일 101

**이메일 프로토콜**

| Protocol | Description |
| --- | --- |
| SMTP(Simple Mail Transfer Protocol) | 이메일을 한 서버에서 다른 서버로 보내는 표준 프로토콜 |
| POP(Post Office Protocol) | 이메일 클라이언트가 원격 메일 서버에서 이메일을 수신하고 다운로드하기 위해 사용하는 표준 프로토콜
→ 일단 단말로 다운로드된 이메일은 서버에서 삭제됨 (1대의 서버에서만 읽기 가능) |
| IMAP(Internet Mail Access Protocol) | 이메일 클라이언트가 원격 메일 서버에서 이메일을 수신하는 데 사용되는 또 다른 표준 프로토콜
→ 클릭하지 않으면 메시지가 다운로드 되지 않고, 서버에서 삭제되지 않음 (여러 서버에서 읽기 가능) |
| HTTPS | 메일 전송 전용 프로토콜은 아니지만, 웹 기반 이메일 시스템의 메일함 접속에 이용 |

이메일을 **보내는** - SMTP / 이메일을 **가져오는** - POP, IMAP

**도메인 이름 서비스 (DNS)**

> 수신자 도메인의 메일 교환기 레코드(Mail Exchange, MX) 검색에 이용
> 

![Untitled](https://github.com/user-attachments/assets/90d7e15c-1cee-4786-897d-2e0700386bd5)

`우선순위` : 선호도를 나타내는 값 (낮을수록 우선순위가 높은 것을 의미)

→ 우선순위가 가장 높은 것부터 최우선으로 연결을 시도하게 된다. 

**첨부 파일**

- Base64 인코딩 사용
- 크기 제한 존재 (e.g. Outlook - 20MB, Gmail - 25MB)
- 다목적 인터넷 메일 확장(MIME, Multi-purpose Internet Mail Extension) - 인터넷을 통해 첨부 파일을 전송할 수 있도록 하는 표준 규격

### 전통적 메일 서버

> 일반적으로 서버 한 대로 운용되는, 사용자가 많지 않을 때 잘 동작하는 시스템
> 

![전통적 메일 서버 아키텍처](https://github.com/user-attachments/assets/5a5803ba-7fdd-49e7-bb71-feabcfe296a7)

전통적 메일 서버 아키텍처

**[사용자A → 사용자B에게 메일을 전송할 때]**

1. 사용자A가 `아웃룩 클라이언트`에 로그인하여 이메일 작성 및 보내기 버튼을 클릭하면 → `아웃룩 메일 서버`로 이메일 전송
    
    *메일 서버 - 클라이언트 : SMTP로 통신
    
2. `아웃룩 메일 서버`는 `DNS` 질의를 통해 수신자 SMTP 서버 주소(지메일)를 검색 → 해당 주소로 이메일을 전송
    
    *메일 서버 간 : SMTP로 통신
    
3. `지메일 서버`는 이메일 저장 후, 수신할 사용자B가 메일을 읽어갈 수 있도록 함
4. 사용자B가 지메일에 로그인하면 `지메일 클라이언트`는 **IMAP/POP 서버**를 통해 새 이메일을 가져옴

**저장소**

- 이메일은 파일 시스템과 디렉터리에 저장된다
    - 각 이메일은 고유한 이름을 가진 **별도 파일**로 보관
    - 각 사용자의 설정 데이터와 메일함은 **사용자 디렉터리**에 보관
- 주로 `*Maildir*`의 디렉터리가 널리 사용됨

### 분산 메일 서버

> 현대적 사용 패턴을 지원하고 확장성과 안정성 문제를 해결한다
> 

**이메일 API**

*메일 클라이언트, 이메일 생명주기 단계마다 상이

- 모바일 단말 클라이언트를 위한 SMTP/POP/IMAP API
- 송신 측 메일 서버와 수신 측 메일 서버 간의 SMTP 통신
- 대화형 웹 기반 이메일 애플리케이션을 위한 HTTP 기반 RESTful API

**`POST` /v1/messages**

To, Tc, Bcc 헤더에 명시된 수신자에게 메시지를 전송하는 API

**`GET` /v1/folders**

주어진 이메일 계정에 존재하는 모든 폴더를 반환하는 API

- Response
    
    ```json
    [{
    		id: string      고유한 폴더 식별자
    		name: string    폴더 이름 (RFC6154에 따르면, 기본 폴더는 All, Archive, Drafts, Flagged, Junk, Sent, Trash 중 하나이다.)
    		user_id: string 계정 소유자 ID
    }]
    ```
    

**`GET` /v1/folders/{:folder_id}/messages**

주어진 폴더 하의 모든 메시지를 반환하는 API  *pagination 등의 지원 고려

- Response
    
    메시지 객체 목록
    

**`GET` /v1/messages/{:message_id}**

주어진 특정 메시지에 대한 모든 정보를 반환하는 API 

→ 메시지 구성 요소 - 발신자, 수신자, 메시지 제목, 본문, 첨부 파일 등

- Response
    
    ```json
    {
    		user_id: string                      // 계정주의 ID
    		from: name: string, email: string    // 발신자의 <이름, 이메일> 쌍
    		to: [name: string, email: string]    // 수신자의 <이름, 이메일> 쌍의 **목록**
    		subject: string                      // 이메일 제목
    		body: string                         // 이메일 본문
    		is_read: boolean                     // 수신자가 메시지를 읽었는지 여부
    }
    ```
    
    메시지 객체
    

**분산 이메일 서버 아키텍처**

> 클라우드 기술을 활용하여 여러 메일 서버 간의 데이터 동기화 및 규모 확장성에 관한 문제를 쉽게 풀어가보자
> 

![개략적 설계안](https://github.com/user-attachments/assets/5416b278-fa71-448b-8d35-de69fd82e9b1)

개략적 설계안

`웹메일` : 사용자는 웹 브라우저를 사용해 메일을 주고 받는다

`웹서버` : 사용자가 이용하는 요청/응답 서비스로, 로그인, 가입, 사용자 프로파일 관리 등의 기능을 담당

→ 모든 이메일 API 요청은 웹서버를 통한다

`실시간 서버` : 새로운 이메일 내역을 클라이언트에 실시간으로 전달하는 역할 

- stateful하게 지속성 연결을 맺고 유지
- 실시간 통신 방식 : 롱 폴링(e.g. 백업용으로도 사용), 웹소켓(e.g. JMAP)

`메타데이터 데이터베이스` : 이메일 메타데이터 저장 DB

`첨부 파일 저장소` : Amazon S3와 같은 객체 저장소 사용

<aside>
💡 카산드라 같은 컬럼 기반 NoSQL DB가 적합하지 않은 이유

- BLOB 자료형, 최대 2GB의 데이터 지원 → but, **1MB 이상의 파일을 지원X**
- 카산드라에 첨부 파일을 저장하면 레코드 캐시를 사용하기 어려움
</aside>

`분산 캐시` : Redis를 활용해 자주 읽을 가능성이 높은 최근에 수신된 이메일을 메모리에 캐시하여 관리

→ 메일 표시 시간 단축, 리스트 등 다양한 기능 제공 가능, 규모 확장에 용이

`검색 저장소` : 분산 문서 저장소로, 고속 텍스트 검색을 지원하는 역 인덱스를 자료구조로 사용

**이베일 발송 및 수신 흐름**

[이메일 전송 절차]

![Untitled](https://github.com/user-attachments/assets/68eab315-1cdb-4877-a108-fdb5476f2625)

- 웹 서버의 역할
    - 기본적인 이메일 검증
    - 수신자 이메일 주소 도메인이 송신자 이메일 주소 도메인과 같은지 검사
- 메시지 큐
    - validation 에 통과한 이메일들은 `외부 전송 큐`로 전달
        - 그중 첨부파일의 크기가 큰 이메일은 **객체 저장소**에 따로 저장 후, 큐에는 해당 저장 위치의 참조 정보만 보관
    - validation 에 통과하지 못한 이메일들은 `에러 큐`에 보관

분산 메시지 큐는 비동기적 메일 처리를 가능하게 하는 핵심 컴포넌트로, 엡 서버에서 외부 전송 담당 SMTP 프로세스를 분리함으로써 전송용 SMTP 프로세스의 규모를 독립적으로 조정할 수 있게 된다. 

<aside>
🚨 처리되지 않은 메시지가 큐에 오래 보관된 채로 있다면? [가능한 원인 Case]

1. 수신자 측 메일 서버에 장애 발생 → 나중에 메일을 다시 전송해야 함
    
    지수적 백오프(Exponential Backoff)가 좋은 전략일 수 있음
    
2. 이메일을 보낼 큐의 소비자 수가 불충분 → 더 많은 소비자를 추가하여 처리 시간을 단축하는 방법 고려
</aside>

[이메일 수신 절차]

![Untitled](https://github.com/user-attachments/assets/3f4d7403-a3e7-4614-9d97-1e7dce9e619b)

*이메일 전송 절차와 거의 유사

- 수신 메시지 큐
    1. 수신 이메일 큐는 메일 처리 작업 프로세스와 SMTP 서버 간의 결합도를 낮추어 각자 독립적으로 규모 확장이 가능하도록 한다.
    2. 갑자기 수신되는 이메일의 양이 폭증하는 경우, 버퍼 역할도 수행
- 메일 처리 작업 프로세스 (validation을 거친 이메일 대상)
    - 스팸 메일 필터링
    - 바이러스 차단
- 오프라인 상태 사용자의 이메일은 저장소 계층에 보관하고, 해당 사용자가 온라인 상태가 되면 웹메일 클라이언트가 웹 서버에 RESTful API를 통해 연결한다

## 3단계 상세 설계

### 메타데이터 데이터베이스

**이메일 메타데이터 특성**

- 이메일의 헤더 - 일반적으로 작고, 빈번하게 이용된다
- 이메일의 본문 - 크기는 다양, 사용 빈도는 낮다 (사용자는 주로 이메일을 1번만 읽기 때문)
- 이메일 가져오기, 읽은 메일로 표시, 검색 등 이메일 관련 작업은 **사용자 별로 격리 수행**되어야 한다 (특정 이메일의 접근 권한은 특정 사용자에게만)
- 데이터의 신선도 - 데이터 사용 패턴에 영향을 미치며, 보통 최근 메일만 읽음
- 데이터의 높은 안정성 - 데이터 손실은 절대 용납 불가

**올바른 DB 선정**

1. 관계형 DB : 이메일을 효율적으로 검색 가능 (검색 질의에 대한 빠른 처리)
    - 데이터의 크기가 작을 때 적합 → 이메일은 수 KB를 초과하는 경우가 많음
    - 비정형 BLOB과 같이 큰 이메일에 접근하려면 많은 디스크 I/O가 발생
2. 분산 객체 저장소 : 이메일 원시 데이터를 그대로 객체 저장소에 보관
    - 백업 데이터 보관에는 좋으나, 다양한 기능 구현에는 그닥..
3. NoSQL DB 
    - e.g. Gmail - 구글의 Bigtable을 저장소로 사용
    - but, Bigtable은 오픈소스로 공개되어 있지 않기 때문에 카산드라를 대안으로 생각해볼 수 있음

⇒ 본 설계안에서 필요로 하는 기능을 완벽하게 지원하는 DB는 없다..!

<aside>
⭐ 최소한 DB가 충족해야 하는 조건 (이 부분만 설명해도 Good)

1. 어떤 단일 컬럼의 크기는 한 자릿수 MB 정도일 수 있다
2. 강력한 데이터 일관성이 보장되어야 한다
3. 디스크 I/O가 최소화되도록 설계되어야 한다
4. 가용성이 아주 높아야 하고 일부 장애를 감내할 수 있어야 한다
5. 증분 백업이 쉬워야 한다
</aside>

**데이터 모델**

> 데이터 저장 방식 : user_id를 파티션 키로 사용하여 특정한 사용자의 데이터를 항상 같은 시드에 보관하는 것
> 

[pk] 

| 파티션 키(partition key) | 클러스터 키(clustering key) |
| --- | --- |
| 데이터를 여러 노드에 분산하는 구실
→ 일반적으로, 데이터가 모든 노드에 균등하게 분산되도록 하는 파티션 키를 골라야 한다는 규칙 존재 | 같은 파티션에 속한 데이터를 정렬하는 구실 |

<aside>
⭐ 이메일 서비스의 데이터 계층이 지원해야 하는 Query

1. 특정 사용자의 모든 폴더 구하기 
    
    → 파티션 키(user_id)로 특정 사용자의 파티션에 접근 (같은 파티션 내에 모든 폴더가 존재하기 때문)
    
2. 특정 폴더에 속한 모든 이메일 표시
    
    → 복합 파티션 키(<user_id, folder_id>), 클러스터 키(email_id, `TIMEUUID`)로 최근 시간순 정렬된 같은 파티션, 폴더에 접근
    
3. 이메일 생성/삭제/수신
    
    *이메일 상세 정보, 첨부파일을 각각 관리하는 2개의 테이블 필요
    
4. 읽은 or 읽지 않은 모든 메일
    
    ```sql
    SELECT * FROM emails_by_folder
    WHERE user_id = <user_id> and folder_id = <folder_id> AND **is_read = true**
    ORDER BY email_id
    ```
    
    → NoSQL DB에서도 동작(파티션 키, 클러스터 키 활용)하게 하려면, **주어진 폴더에 속한 모든 메시지를 가져온 다음, 애플리케이션 단에서 필터링을 수행하는 대안**이 있다. 
    
    > 테이블 비정규화를 위해 emails_by_folder 테이블을 read_emails (읽은 모든 이메일) / unread_emails (읽지 않은 모든 이메일) 2개로 분할하는 방식  ***(is_read 조건이 필요 없어짐)***
    > 
5. 보너스 점수를 받을 수 있는 질의 : 이메일 타래(threads)를 전부 가져오기
    
    모든 답장을 최초 메시지에 타래로 엮어 보여주는 기능 ⇒ 사용자는 특정한 대화에 관련된 모든 메일을 한 번에 확인할 수 있게 된다
    
    → 이메일 헤더 정보를 이용하는 JWZ 알고리즘으로 구현
    
    ```json
    // 이메일 헤더
    {
    	"headers": {
    		"Message-Id": "<8BA024-4DSD-2FWD@gmail.com>",   // 메시지 식별자. 메시지를 보내는 클라이언트가 생성
    		"In-Reply-To": "<CAEXWEW2=KSFJCVW TW@gmail.com>",  // 이 메시지가 어떤 메시지에 대한 답신인지 나타내는 식별자
    		"References": ["<8BA024-4DSD-2FWD@gmail.com>"]  // 타래에 관계된 메시지 식별자 목록
    	}
    }
    ```
    
    위 필드들을 이용해 이메일 클라이언트는 타래 내의 모든 메시지가 사전에 메모리로 로드되어 있다면, 타래 재구성이 가능하다
    
</aside>

**일관성 문제**

이메일 서비스는 데이터의 정확성이 무엇보다 중요하므로, 장애가 발생하면 다른 사본을 통해 주 사본이 복원될 때까지 동기화/갱신 작업을 중단한다. 차라리 가용성을 희생하는 방안을 택하는 것이다. 

### 전송가능성(deliverability)

*스팸 메일로 분류되지 않도록 하는 방법 등..

`전용 IP` : 이메일을 보낼 때는 전용 IP 주소를 사용할 것 (대부분의 이메일 서비스 사업자에서 새로운 IP 주소는 무시하므로)

`범주화` : 범주가 다른 이메일은 다른 IP 주소(서로 다른 서버)를 통해 보낼 것 

`발신인 평판` : 새로운 이메일 서버의 IP 주소는 사용 빈도를 서서히 올려서 보낼 것

e.g. Amazon SES에 따르면, 새로운 IP 주소를 메일 발송에 아무 문제 없이 쓸 수 있게 되는 데는 대략 2~6주가 소요된다.

`스팸 발송자의 신속한 차단` : 스팸을 뿌리는 사용자는 신속히 차단 필요

`피드백 처리` : ISP 측에서의 피드백을 쉽게 받아 처리할 수 있는 경로를 만들 것

![Untitled](https://github.com/user-attachments/assets/7f775904-ec86-46bf-ab34-9e2b7bd902d3)

| 경성 반송(hard bounce) | 수신인의 이메일 주소가 올바르지 않아 ISP가 전달을 거부한 경우 |
| --- | --- |
| 연성 반송(soft bounce) | ISP 측의 이메일 처리 지원 부족 등의 이유로 일시적으로 이메일을 전달할 수 없었던 경우 |
| 불만 신고(complaint) | 수신인이 ‘스팸으로 신고’ 버튼을 누른 경우 |

`이메일 인증` : 피싱, 프리텍스팅에 의해 유출 사고가 발생하지 않도록 SPF(Sender Policy Framework), DKIM(DomainKeys Identified Mail), DMARC(Domain-based Message Authentication, Reporting and Conformance) 등의 전략을 함께 도입하는 것

→ 헤더에 해당 검증을 거쳤다는 사실 기록

### 검색

> 이메일 제목이나 본문에 특정 키워드가 포함되었는지 찾는 것
> 

[고급 기능] 발신인(From), 제목(Subject), 읽지 않음 등의 메일 속성에 따른 필터링 기능

- 전송/수신/삭제 시마다 indexing을 수행해야 함
- write >>> read

[구글 검색 VS 이메일 검색]

|  | 범위 | 장점 | 정확도 |
| --- | --- | --- | --- |
| 구글 검색 | 인터넷 전체 | 관련성에 따라 | indexing에 시간이 걸리므로 새로운 항목이 검색 결과에 즉시 나타나지 않을 수 있음 |
| 이메일 검색 | 사용자의 메일함 | 시각, 첨부 파일, 날짜 밤위 내, 읽음 여부 등의 속성을 기준으로 정렬 | indexing 작업은 거의 실시간으로 이루어져야 하고 검색 결과는 정확해야 함 |

**방안1: ElasticSearch**

같은 사용자(user_id)의 이메일은 같은 노드에 묶어 놓는다

- 사용자가 `검색` 버튼을 누른 다음 결과가 수신될 때까지 기다리는 ***sync 방식*** 으로 처리
- 이벤트 처리 결과는 클라이언트로 전달될 필요 X
- indexing은 백그라운드에서 진행

![Untitled](https://github.com/user-attachments/assets/d4d10ef6-4e4d-45d2-82a4-fceb4e7350f9)

<aside>
⭐ 카프카를 활용하여 indexing을 시작하는 서비스 <> 실제로 indexing을 수행할 서비스 사이의 결합도를 낮추자!

</aside>

> ElasticSearch
> 
> 
>  널리 사용되는 검색엔진 DB로, 이메일 검색에 필요한 **텍스트 기반 검색** 지원 Good
> 

**방안2: 맞춤형 검색 솔루션**

디스크 I/O에 대비하여, indexing을 구축하는 프로세스(다량의 write 연산)는 LSM(Long Structured Merge) 트리를 사용하는 전략으로 최적화 할 수 있다. 

*LSM 트리: 빅테이블, 카산드라, RocksDB에서의 핵심 자료구조 

→ `목적` 자주 바뀌는 데이터 O/X를 분리하기 위함

1. 새로운 이메일이 도착하면 우선 메모리 캐시로 구현되는 0번 계층에 추가
2. 메모리에 보관된 데이터 양이 임계치를 초과하면, 데이터는 다음 계층에 병합

[비교]

|  | ElasticSearch | 맞춤형 검색 엔진 |
| --- | --- | --- |
| 규모 확장성 | 어느 정도 확장 가능 | 이메일 사용 패턴에 따라 시스템 최적화 가능 |
| 시스템 복잡도 | 두 가지 상이한 시스템을 동시에 유지해야 함 | 하나의 시스템 |
| 데이터 일관성 | 한 데이터의 두 사본이 존재 (메타데이터 저장소 / ElasticSearch)
→ 데이터 일관성을 유지하기 까다로움 | 메타데이터 저장소에 하나의 사본만 유지 |
| 데이터 손실 가능성 | X → 색인이 손상되면 주 저장소의 데이터로 복구 | X |
| 개발 비용 | 통합하기 쉬운 편. 대규모 이메일 검색이 필요한 경우에는 전담하는 팀의 리소스 필요 | 굉장히 많은 엔지니어링 노력이 필요함 |

### 규모 확장성 및 가용성

![여러 데이터센터를 통한 시스템 다중화](https://github.com/user-attachments/assets/cc8529dc-489f-401d-a723-9ce6d2705c35)

여러 데이터센터를 통한 시스템 다중화

각 사용자의 데이터 접근 패턴은 다른 사용자와 무관하므로, 시스템의 대부분 컴포넌트는 수평적으로 규모 확장 가능하다고 기대할 수 있다.

⇒ 여러 데이터센터에 데이터를 다중화하자!

👤 사용자는 네트워크 토폴로지 측면에서 가장 물리적으로 가까운 메일 서버와 통신하게 된다

🌐 네트워크 파티션 자체에서 통신이 불가능한 장애가 발생하면, 사용자는 다른 데이터센터에 보관된 메시지를 이용하게 된다

## 4단계 마무리

### 추가로 논의해볼만 한 주제

- 결함 내성
    
    노드 장애, 네트워크 문제, 이벤트 전달 지연 등의 문제에 어떻게 대처할 수 있을지?
    
- 규정 준수
    
    각 나라마다 준수해야 할 법규를 어떻게 고려하면 좋을지?  → **합법적 감청(legal intercept)**
    
    e.g. 유럽 - GDPR(General Data Protection Regulation) 기준에 따라 개인 식별 정보(PII)를 처리하고 저장해야 함
    
- 보안
    
    민감 정보가 포함될 가능성이 높은 이메일 데이터를 다루며, 아래와 같은 보안 기능을 고려해볼 수 있다.
    
    - `피싱 방지` : 파싱이나 멀웨어 공격을 방지
    - `안전 브라우징` : 안전하지 않은 사이트 경고
    - `사전 경고` : 보안 결함이 있는 첨부파일이 포함된 경우
    - `계정 안전` : 의심스러운 로그인 시도 차단
    - `기밀 모드` : 송신자가 메시지에 대한 보안 정책을 설정할 수 있도록 기능 제공
    - `이메일 암호화` : 타인이 이메일 내용을 엿보지 않도록 방지
- 최적화
    
    같은 이메일이 여러 수신자에게 전송되는 경우, 같은 첨부파일이 S3에 여러 번 저장될 수 있다. 이를 최적화하려면 저장하기 전에 **이미 저장소에 존재하는 파일인지 확인**하면 저장 연산 실행 비용을 절감할 수 있다. 
    

### 요약

![Untitled](https://github.com/user-attachments/assets/818dfbed-d6b6-4d6f-8daa-9909a5e2633b)
